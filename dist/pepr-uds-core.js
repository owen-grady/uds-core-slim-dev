"use strict";var Ne=Object.defineProperty;var a=(e,t)=>Ne(e,"name",{value:t,configurable:!0});var ht=(e,t)=>{for(var o in t)Ne(e,o,{get:t[o],enumerable:!0})};var yt=require("pepr");var Ie={name:"uds-core",version:"0.4.0",description:"A collection of capabilities for UDS Core",keywords:["pepr","k8s","policy-engine","pepr-module","security"],engines:{node:">=20.0.0"},pepr:{name:"UDS Core",uuid:"uds-core",onError:"reject",logLevel:"debug",alwaysIgnore:{namespaces:["uds-dev-stack","zarf"],labels:[]},env:{UDS_DOMAIN:"###ZARF_VAR_DOMAIN###",UDS_ALLOW_ALL_NS_EXEMPTIONS:"###ZARF_VAR_ALLOW_ALL_NS_EXEMPTIONS###",UDS_SINGLE_TEST:"###ZARF_VAR_UDS_SINGLE_TEST###"}},scripts:{"k3d-setup":"k3d cluster delete pepr-dev && k3d cluster create pepr-dev --k3s-arg '--debug@server:0'"},dependencies:{pepr:"0.28.7"},devDependencies:{"@jest/globals":"29.7.0",jest:"29.7.0","ts-jest":"29.1.2"},jest:{preset:"ts-jest",testEnvironment:"node",globalSetup:"./jest.setup.js",globalTeardown:"./jest.teardown.js"}};var Q=require("@kubernetes/client-node"),b=require("pepr"),le=new b.Capability({name:"istio",description:"UDS Core Capability for Istio service mesh."}),{When:Pt}=le,de=new Set;Pt(b.a.Pod).IsCreatedOrUpdated().WithLabel("batch.kubernetes.io/job-name").WithLabel("service.istio.io/canonical-name").Watch(async e=>{if(b.Log.info(e,`Processing Pod ${e.metadata?.namespace}/${e.metadata?.name} for istio job termination`),!e.metadata?.name||!e.metadata.namespace){b.Log.error(e,"Invalid Pod definition");return}let{name:t,namespace:o}=e.metadata,r=`${o}/${t}`;if(!de.has(r)&&e.status?.phase=="Running"){if(!e.status.containerStatuses){b.Log.error(e,"Invalid container status in Pod");return}if(e.status.containerStatuses.filter(n=>n.name!="istio-proxy").every(n=>n.state?.terminated&&n.state.terminated.exitCode==0)){de.add(r),b.Log.info(`Attempting to terminate sidecar for ${r}`);try{let n=new Q.KubeConfig;n.loadFromDefault(),await new Q.Exec(n).exec(o,t,"istio-proxy",["pilot-agent","request","POST","/quitquitquit"],null,null,process.stdin,!0),b.Log.info(`Terminated sidecar for ${r}`)}catch(n){b.Log.error({err:n},`Failed to terminate the sidecar for ${r}`),de.delete(r)}}}});var Te=require("pepr");var Me=require("pepr");var S=require("pepr");var Ee={name:"v1alpha1",served:!0,storage:!0,additionalPrinterColumns:[{name:"Status",type:"string",description:"The status of the exemption",jsonPath:".status.phase"},{name:"Exemptions",type:"string",description:"Titles of the exemptions",jsonPath:".status.titles"},{name:"Age",type:"date",description:"The age of the exemption",jsonPath:".metadata.creationTimestamp"}],subresources:{status:{}},schema:{openAPIV3Schema:{type:"object",properties:{status:{type:"object",properties:{observedGeneration:{type:"integer"},phase:{enum:["Pending","Ready","Failed"],type:"string"},titles:{type:"array",items:{type:"string"}}}},spec:{type:"object",properties:{exemptions:{type:"array",description:"Policy exemptions",items:{type:"object",required:["policies","matcher"],properties:{title:{type:"string",description:"title to give the exemption for reporting purposes"},description:{type:"string",description:"Reasons as to why this exemption is needed"},policies:{description:"A list of policies to override",type:"array",items:{type:"string",enum:["DisallowHostNamespaces","DisallowNodePortServices","DisallowPrivileged","DisallowSELinuxOptions","DropAllCapabilities","RequireNonRootUser","RestrictCapabilities","RestrictExternalNames","RestrictHostPathWrite","RestrictHostPorts","RestrictProcMount","RestrictSeccomp","RestrictSELinuxType","RestrictVolumeTypes"]}},matcher:{description:"Resource to exempt (Regex allowed for name)",type:"object",required:["namespace","name"],properties:{namespace:{type:"string"},name:{type:"string"},kind:{type:"string",enum:["pod","service"],default:"pod"}}}}}}}}}}}};var Ue=[{required:["exact"]},{required:["prefix"]},{required:["regex"]}],Z={oneOf:[{not:{anyOf:Ue}},...Ue],properties:{exact:{type:"string"},prefix:{type:"string"},regex:{description:"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).",type:"string"}},type:"object"},me={description:"Advanced HTTP settings for the route.",properties:{corsPolicy:{description:"Cross-Origin Resource Sharing policy (CORS).",properties:{allowCredentials:{description:"Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.",nullable:!0,type:"boolean"},allowHeaders:{description:"List of HTTP headers that can be used when requesting the resource.",items:{type:"string"},type:"array"},allowMethods:{description:"List of HTTP methods allowed to access the resource.",items:{type:"string"},type:"array"},allowOrigin:{items:{type:"string"},type:"array"},allowOrigins:{description:"String patterns that match allowed origins.",items:Z,type:"array"},exposeHeaders:{description:"A list of HTTP headers that the browsers are allowed to access.",items:{type:"string"},type:"array"},maxAge:{description:"Specifies how long the results of a preflight request can be cached.",type:"string"}},type:"object"},directResponse:{description:"A HTTP rule can either return a direct_response, redirect or forward (default) traffic.",properties:{body:{description:"Specifies the content of the response body.",oneOf:[{not:{anyOf:[{required:["string"]},{required:["bytes"]}]}},{required:["string"]},{required:["bytes"]}],properties:{bytes:{description:"response body as base64 encoded bytes.",format:"binary",type:"string"},string:{type:"string"}},type:"object"},status:{description:"Specifies the HTTP response status to be returned.",type:"integer"}},required:["status"],type:"object"},headers:{properties:{request:{properties:{add:{additionalProperties:{type:"string"},type:"object"},remove:{items:{type:"string"},type:"array"},set:{additionalProperties:{type:"string"},type:"object"}},type:"object"},response:{properties:{add:{additionalProperties:{type:"string"},type:"object"},remove:{items:{type:"string"},type:"array"},set:{additionalProperties:{type:"string"},type:"object"}},type:"object"}},type:"object"},match:{description:"Match the incoming request based on custom rules. Not permitted when using the passthrough gateway.",items:{properties:{ignoreUriCase:{description:"Flag to specify whether the URI matching should be case-insensitive.",type:"boolean"},method:Z,name:{description:"The name assigned to a match.",type:"string"},queryParams:{additionalProperties:Z,description:"Query parameters for matching.",type:"object"},uri:Z},required:["name"],type:"object"},type:"array"},rewrite:{description:"Rewrite HTTP URIs and Authority headers.",properties:{authority:{description:"rewrite the Authority/Host header with this value.",type:"string"},uri:{description:"rewrite the path (or the prefix) portion of the URI with this value.",type:"string"},uriRegexRewrite:{description:"rewrite the path portion of the URI with the specified regex.",properties:{match:{description:"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).",type:"string"},rewrite:{description:"The string that should replace into matching portions of original URI.",type:"string"}},type:"object"}},type:"object"},retries:{description:"Retry policy for HTTP requests.",properties:{attempts:{description:"Number of retries to be allowed for a given request.",format:"int32",type:"integer"},perTryTimeout:{description:"Timeout per attempt for a given request, including the initial call and any retries.",type:"string"},retryOn:{description:"Specifies the conditions under which retry takes place.",type:"string"},retryRemoteLocalities:{description:"Flag to specify whether the retries should retry to other localities.",nullable:!0,type:"boolean"}},type:"object"},weight:{description:"Weight specifies the relative proportion of traffic to be forwarded to the destination.",format:"int32",type:"integer"},timeout:{description:"Timeout for HTTP requests, default is disabled.",type:"string"}},type:"object"};var wt={description:"Allow specific traffic (namespace will have a default-deny policy)",type:"array",items:{type:"object",required:["direction"],properties:{labels:{description:"The labels to apply to the policy",type:"object",additionalProperties:{type:"string"}},description:{type:"string",description:"A description of the policy, this will become part of the policy name"},direction:{description:"The direction of the traffic",enum:["Ingress","Egress"],type:"string"},selector:{description:"Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all pods in the namespace",type:"object",additionalProperties:{type:"string"}},remoteNamespace:{description:"The remote namespace to allow traffic to/from. Use * or empty string to allow all namespaces",type:"string"},remoteSelector:{description:"The remote pod selector labels to allow traffic to/from",type:"object",additionalProperties:{type:"string"}},remoteGenerated:{description:"Custom generated remote selector for the policy",type:"string",enum:["KubeAPI","IntraNamespace","CloudMetadata","Anywhere"]},port:{description:"The port to allow (protocol is always TCP)",minimum:1,maximum:65535,type:"number"},ports:{description:"A list of ports to allow (protocol is always TCP)",type:"array",items:{minimum:1,maximum:65535,type:"number"}},podLabels:{description:"Deprecated: use selector",type:"object",additionalProperties:{type:"string"}},remotePodLabels:{description:"Deprecated: use remoteSelector",type:"object",additionalProperties:{type:"string"}}}}},bt={type:"array",description:"Expose a service on an Istio Gateway",items:{type:"object",required:["host"],anyOf:[{required:["service","podLabels","port"]},{required:["service","selector","port"]},{required:["advancedHTTP"]}],properties:{description:{type:"string",description:"A description of this expose entry, this will become part of the VirtualService name"},host:{description:"The hostname to expose the service on",type:"string"},gateway:{description:"The name of the gateway to expose the service on (default: tenant)",enum:["admin","tenant","passthrough"],type:"string",default:"tenant"},service:{description:"The name of the service to expose",type:"string"},port:{description:"The port number to expose",minimum:1,maximum:65535,type:"number"},selector:{description:"Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all pods in the namespace",type:"object",additionalProperties:{type:"string"}},targetPort:{description:"The service targetPort. This defaults to port and is only required if the service port is different from the target port (so the NetworkPolicy can be generated correctly).",minimum:1,maximum:65535,type:"number"},advancedHTTP:me,match:{description:"Deprecated: use advancedHTTP.match",...me.properties?.match},podLabels:{description:"Deprecated: use selector",type:"object",additionalProperties:{type:"string"}}}}},St={description:"Create SSO client configurations",type:"array",items:{type:"object",required:["clientId","name","redirectUris"],properties:{isAuthSvcClient:{description:"If true, the client will generate a new Auth Service client as well",type:"boolean",default:!1},secretName:{description:"The name of the secret to store the client secret",type:"string"},secretTemplate:{description:"A template for the generated secret",type:"object",additionalProperties:{type:"string"}},clientId:{description:"The client identifier registered with the identity provider.",type:"string"},secret:{description:"The client secret. Typically left blank and auto-generated.",type:"string"},name:{description:"Specifies display name of the client",type:"string"},description:{description:"A description for the client, can be a URL to an image to replace the login logo",type:"string"},rootUrl:{description:"Root URL appended to relative URLs",type:"string"},redirectUris:{description:"Valid URI pattern a browser can redirect to after a successful login. Simple wildcards are allowed such as 'https://unicorns.uds.dev/*'",type:"array",items:{type:"string"},minItems:1},webOrigins:{description:"Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does not include the '*' wildcard though. To permit all origins, explicitly add '*'.",type:"array",items:{type:"string"}},enabled:{description:"Whether the SSO client is enabled",type:"boolean",default:!0},alwaysDisplayInConsole:{description:"Always list this client in the Account UI, even if the user does not have an active session.",type:"boolean",default:!1},clientAuthenticatorType:{description:"The client authenticator type",type:"string",enum:["client-secret","client-jwt"]},defaultClientScopes:{description:"Default client scopes",type:"array",items:{type:"string"}}}}},Oe={name:"v1alpha1",served:!0,storage:!0,additionalPrinterColumns:[{name:"Status",type:"string",description:"The status of the package",jsonPath:".status.phase"},{name:"SSO Clients",type:"string",description:"SSO Clients created by the package",jsonPath:".status.ssoClients"},{name:"Endpoints",type:"string",description:"Service endpoints exposed by the package",jsonPath:".status.endpoints"},{name:"Network Policies",type:"integer",description:"The number of network policies created by the package",jsonPath:".status.networkPolicyCount"},{name:"Age",type:"date",description:"The age of the package",jsonPath:".metadata.creationTimestamp"}],subresources:{status:{}},schema:{openAPIV3Schema:{type:"object",properties:{status:{type:"object",properties:{observedGeneration:{type:"integer"},phase:{enum:["Pending","Ready","Failed"],type:"string"},ssoClients:{type:"array",items:{type:"string"}},endpoints:{type:"array",items:{type:"string"}},networkPolicyCount:{type:"integer"}}},spec:{type:"object",properties:{network:{type:"object",description:"Network configuration for the package",properties:{expose:bt,allow:wt}},sso:St}}}}}};(process.env.PEPR_WATCH_MODE==="true"||process.env.PEPR_MODE==="dev")&&((0,S.K8s)(S.kind.CustomResourceDefinition).Apply({apiVersion:"apiextensions.k8s.io/v1",kind:"CustomResourceDefinition",metadata:{name:"packages.uds.dev"},spec:{group:"uds.dev",versions:[Oe],scope:"Namespaced",names:{plural:"packages",singular:"package",kind:"Package",shortNames:["pkg"]}}},{force:!0}).then(()=>{S.Log.info("CRD registered")}).catch(e=>{S.Log.error({err:e},"Failed to register CRD"),process.exit(1)}),(0,S.K8s)(S.kind.CustomResourceDefinition).Apply({apiVersion:"apiextensions.k8s.io/v1",kind:"CustomResourceDefinition",metadata:{name:"exemptions.uds.dev"},spec:{group:"uds.dev",versions:[Ee],scope:"Namespaced",names:{plural:"exemptions",singular:"exemption",kind:"Exemption",shortNames:["exempt"]}}},{force:!0}).then(()=>{S.Log.info("Exemption CRD registered")}).catch(e=>{S.Log.error(e),process.exit(1)}));var X=new Me.Capability({name:"uds-core-operator",description:"The UDS Operator is responsible for managing the lifecycle of UDS resources"}),{Store:_,When:I}=X;var W=require("pepr");var A=require("pepr");var Y=require("kubernetes-fluent-client");var k=class extends Y.GenericKind{static{a(this,"Package")}spec;status};(0,Y.RegisterKind)(k,{group:"uds.dev",version:"v1alpha1",kind:"Package"});var q=require("kubernetes-fluent-client");var T=class extends q.GenericKind{static{a(this,"Exemption")}spec;status};var D=(m=>(m.DisallowHostNamespaces="DisallowHostNamespaces",m.DisallowNodePortServices="DisallowNodePortServices",m.DisallowPrivileged="DisallowPrivileged",m.DisallowSELinuxOptions="DisallowSELinuxOptions",m.DropAllCapabilities="DropAllCapabilities",m.RequireNonRootUser="RequireNonRootUser",m.RestrictCapabilities="RestrictCapabilities",m.RestrictExternalNames="RestrictExternalNames",m.RestrictHostPathWrite="RestrictHostPathWrite",m.RestrictHostPorts="RestrictHostPorts",m.RestrictProcMount="RestrictProcMount",m.RestrictSELinuxType="RestrictSELinuxType",m.RestrictSeccomp="RestrictSeccomp",m.RestrictVolumeTypes="RestrictVolumeTypes",m))(D||{});(0,q.RegisterKind)(T,{group:"uds.dev",version:"v1alpha1",kind:"Exemption"});var V={};ht(V,{DerivePort:()=>Le,VirtualService:()=>ee});var te=require("kubernetes-fluent-client");var ee=class extends te.GenericKind{static{a(this,"VirtualService")}spec;status},Le=(o=>(o.FromProtocolDefault="FROM_PROTOCOL_DEFAULT",o.FromRequestPort="FROM_REQUEST_PORT",o))(Le||{});(0,te.RegisterKind)(ee,{group:"networking.istio.io",version:"v1beta1",kind:"VirtualService"});var $e=require("pepr");var E=new $e.Capability({name:"uds-core-policies",description:"Collection of core validation policies for Pods, ConfigMaps, and other Kubernetes resources."}),{Store:je,When:g}=E;function ge(e){return e.Raw.spec?.volumes||[]}a(ge,"volumes");function U(e){return[...e.Raw.spec?.containers||[],...e.Raw.spec?.initContainers||[],...e.Raw.spec?.ephemeralContainers||[]]}a(U,"containers");function C(e){return U(e).filter(t=>t.securityContext).filter(t=>!Rt(e,t)).map(t=>({name:t.name,ctx:t.securityContext}))}a(C,"securityContextContainers");function w(e,t,o){let r=o.map(n=>JSON.stringify(n)).join(" | "),i=t.filter(n=>n).join(" | ");return`${e}. Authorized: [${i}] Found: ${r}`}a(w,"securityContextMessage");function Rt(e,t){return!(!e.HasAnnotation("sidecar.istio.io/status")||!e.Raw.spec?.containers?.find(n=>n.name==="istio-proxy"&&n.ports?.find(s=>s.name==="http-envoy-prom")&&n.args?.includes("proxy"))||!(t?.name==="istio-init"&&t.args?.includes("istio-iptables")))}a(Rt,"isIstioInitContainer");function kt(e){return e.split(/(?=[A-Z])/).join("-").toLowerCase()}a(kt,"transform");function ye(e,t){e.SetAnnotation("uds-core.pepr.dev/mutated",kt(t))}a(ye,"annotateMutation");var He=require("pepr");function f(e,t){let o=JSON.parse(je.getItem(t)||"[]");for(let r of o){if(r.namespace&&r.namespace!==e.Raw.metadata?.namespace)continue;let i=e.Raw.metadata?.name||e.Raw.metadata?.generateName;if(!(r.name&&!i?.match(r.name)))return He.Log.info("request is exempt",{exempt:r}),!0}return!1}a(f,"isExempt");function y(e){return t=>{if(f(t,e)){t.SetAnnotation(`uds-core.pepr.dev/uds-core-policies.${e}`,"exempted");return}}}a(y,"markExemption");g(A.a.Pod).IsCreatedOrUpdated().Mutate(y("DisallowPrivileged")).Validate(e=>{if(f(e,"DisallowPrivileged"))return e.Approve();let t=C(e).filter(o=>o.ctx.allowPrivilegeEscalation||o.ctx.privileged);return t.length?e.Deny(w("Privilege escalation is disallowed",["allowPrivilegeEscalation = false","privileged = false"],t)):e.Approve()});g(A.a.Pod).IsCreatedOrUpdated().Mutate(e=>{if(y("RequireNonRootUser")(e),e.HasAnnotation("uds-core.pepr.dev/uds-core-policies.RequireNonRootUser"))return;let t=e.Raw.spec,o=e.Raw.metadata||{};t.securityContext=t.securityContext||{};let r=o.labels?.["uds/user"];r&&(t.securityContext.runAsUser=parseInt(r));let i=o.labels?.["uds/group"];i&&(t.securityContext.runAsGroup=parseInt(i));let n=o.labels?.["uds/fsgroup"];n&&(t.securityContext.fsGroup=parseInt(n)),t.securityContext.runAsNonRoot===void 0&&(t.securityContext.runAsNonRoot=!0),t.securityContext.runAsUser===void 0&&(t.securityContext.runAsUser=1e3),t.securityContext.runAsGroup===void 0&&(t.securityContext.runAsGroup=1e3),ye(e,"RequireNonRootUser")}).Validate(e=>{if(f(e,"RequireNonRootUser"))return e.Approve();let t=a(i=>{let n=i.runAsNonRoot===!1,s=i.runAsUser===0;return n||s},"isRoot"),o=e.Raw.spec?.securityContext||{};if(t(o))return e.Deny("Pod level securityContext does not meet the non-root user requirement.");let r=C(e).filter(i=>t(i.ctx));return r.length?e.Deny(w("Unauthorized container securityContext. Containers must not run as root",["runAsNonRoot = false","runAsUser > 0"],r)):e.Approve()});g(A.a.Pod).IsCreatedOrUpdated().Mutate(y("RestrictProcMount")).Validate(e=>{if(f(e,"RestrictProcMount"))return e.Approve();let t=[void 0,"Default"],o=C(e).filter(r=>!t.includes(r.ctx.procMount));return o.length?e.Deny(w("Unauthorized procMount type",t,o)):e.Approve()});g(A.a.Pod).IsCreatedOrUpdated().Mutate(y("RestrictSeccomp")).Validate(e=>{if(f(e,"RestrictSeccomp"))return e.Approve();let t=[void 0,"RuntimeDefault","Localhost"],o=e.Raw.spec?.securityContext||{};if(!t.includes(o.seccompProfile?.type))return e.Deny(w("Unauthorized pod seccomp profile type",t,[{ctx:o}]));let r=C(e).filter(i=>!t.includes(i.ctx.seccompProfile?.type));return r.length?e.Deny(w("Unauthorized container seccomp profile type",t,r)):e.Approve()});g(A.a.Pod).IsCreatedOrUpdated().Mutate(y("DisallowSELinuxOptions")).Validate(e=>{if(f(e,"DisallowSELinuxOptions"))return e.Approve();let t=e.Raw.spec?.securityContext?.seLinuxOptions,o=["user: undefined","role: undefined"];if(t?.user||t?.role)return e.Deny(w("Unauthorized pod SELinux Options",o,[{ctx:e.Raw.spec?.securityContext}]));let r=C(e).filter(i=>i.ctx.seLinuxOptions?.user||i.ctx.seLinuxOptions?.role);return r.length?e.Deny(w("Unauthorized container SELinux Options",o,r)):e.Approve()});g(A.a.Pod).IsCreatedOrUpdated().Mutate(y("RestrictSELinuxType")).Validate(e=>{if(f(e,"RestrictSELinuxType"))return e.Approve();let t=[void 0,"container_t","container_init_t","container_kvm_t"],o=e.Raw.spec?.securityContext?.seLinuxOptions?.type;if(!t.includes(o))return e.Deny(w("Unauthorized pod SELinux type",t,[{ctx:e.Raw.spec?.securityContext}]));let r=C(e).filter(i=>!t.includes(i.ctx.seLinuxOptions?.type));return r.length?e.Deny(w("Unauthorized container SELinux type",t,r)):e.Approve()});g(A.a.Pod).IsCreatedOrUpdated().Mutate(e=>{if(y("DropAllCapabilities")(e),!e.HasAnnotation("uds-core.pepr.dev/uds-core-policies.RequireNonRootUser")){for(let t of U(e))t.securityContext=t.securityContext||{},t.securityContext.capabilities=t.securityContext.capabilities||{},t.securityContext.capabilities.drop=["ALL"];ye(e,"DropAllCapabilities")}}).Validate(e=>{if(f(e,"DropAllCapabilities"))return e.Approve();let t="ALL",o=C(e).filter(r=>!r.ctx.capabilities?.drop?.includes(t));return o.length?e.Deny(w("Unauthorized container DROP capabilities in securityContext.capabilities.drop",[t],o)):e.Approve()});g(A.a.Pod).IsCreatedOrUpdated().Mutate(y("RestrictCapabilities")).Validate(e=>{if(f(e,"RestrictCapabilities"))return e.Approve();let t=["NET_BIND_SERVICE"],o=C(e).filter(r=>r.ctx?.capabilities?.add&&!r.ctx?.capabilities.add.includes(t[0]));return o.length?e.Deny(w("Unauthorized container capabilities in securityContext.capabilities.add",t,o)):e.Approve()});var he=require("pepr");g(he.a.Pod).IsCreatedOrUpdated().Mutate(y("RestrictVolumeTypes")).Validate(e=>{let t=["configMap","csi","downwardAPI","emptyDir","ephemeral","persistentVolumeClaim","projected","secret"];if(f(e,"RestrictVolumeTypes"))return e.Approve();for(let o of ge(e)){let r=Object.keys(o).find(i=>i!=="name")||"unknown";if(!t.includes(r))return e.Deny(`Volume ${o.name} has a disallowed volume type of '${r}'.`)}return e.Approve()});g(he.a.Pod).IsCreatedOrUpdated().Mutate(y("RestrictHostPathWrite")).Validate(e=>{if(f(e,"RestrictHostPathWrite"))return e.Approve();for(let t of ge(e))if(t.hostPath&&U(e).flatMap(r=>r.volumeMounts||[]).filter(r=>r.name===t.name).find(r=>!r.readOnly))return e.Deny(`hostPath volume '${t.name}' must be mounted as readOnly.`);return e.Approve()});var G=require("pepr");g(G.a.Pod).IsCreatedOrUpdated().Mutate(y("DisallowHostNamespaces")).Validate(e=>{if(f(e,"DisallowHostNamespaces"))return e.Approve();let t=e.Raw.spec;return t.hostNetwork||t.hostIPC||t.hostPID?e.Deny("Sharing the host namespaces is disallowed. The fields spec.hostNetwork, spec.hostIPC, and spec.hostPID must not be set to true."):e.Approve()});g(G.a.Pod).IsCreatedOrUpdated().Mutate(y("RestrictHostPorts")).Validate(e=>f(e,"RestrictHostPorts")?e.Approve():U(e).flatMap(o=>o.ports||[]).find(o=>o.hostPort)?e.Deny("Host ports are not allowed."):e.Approve());g(G.a.Service).IsCreatedOrUpdated().Mutate(y("RestrictExternalNames")).Validate(e=>f(e,"RestrictExternalNames")?e.Approve():e.Raw.spec?.type==="ExternalName"?e.Deny("ExternalName services are not allowed."):e.Approve());g(G.a.Service).IsCreatedOrUpdated().Mutate(y("DisallowNodePortServices")).Validate(e=>f(e,"DisallowNodePortServices")?e.Approve():e.Raw.spec?.type==="NodePort"?e.Deny("NodePort services are not allowed."):e.Approve());var $=a((e,t)=>e.name===t.name&&e.namespace===t.namespace&&e.kind==t.kind&&e.owner===t.owner,"isSame");function Tt(e,t,o,r){let i=t.get(e)??[],n={...o.matcher,owner:r},s=i.some(l=>$(l,n));o.policies.includes(e)&&!s&&t.set(e,[...i,n])}a(Tt,"addIfIncludesPolicy");function Dt(e,t,o,r){let i={...o.matcher,owner:r},n=t.get(e)??[];n.some(s=>$(s,i))&&!o.policies.includes(e)&&(t.set(e,n.filter(s=>{if(!$(s,i))return s})),W.Log.debug(`Removing ${i.name} from ${e}`))}a(Dt,"deleteIfPolicyRemoved");function Ct(e,t,o,r){let i=t.get(e)||[];for(let n of i.filter(s=>s.owner===r)){let s=!0;for(let l of o)$(n,l)&&(s=!1);if(s){let l=t.get(e)||[];t.set(e,l.filter(d=>{if(!$(d,n))return d})),W.Log.debug(`Removing ${n.name} from ${e}`)}}}a(Ct,"deleteIfMatchersRemoved");function Fe(e){let{Store:t}=E;for(let[o,r]of e.entries())W.Log.debug(`Updating uds policy ${o} exemptions: ${JSON.stringify(r)}`),t.setItem(o,JSON.stringify(r))}a(Fe,"updateStore");function _e(){let{Store:e}=E,t=new Map,o=Object.values(D);for(let r of o)t.set(r,JSON.parse(e.getItem(r)||"[]"));return{policyMap:t,policyList:o}}a(_e,"setupPolicyMap");function Ge(e){let{policyMap:t,policyList:o}=_e(),r=[],i=e.metadata?.uid||"";for(let n of o){for(let s of e.spec?.exemptions??[])r.push({...s.matcher,owner:i}),Tt(n,t,s,i),Dt(n,t,s,i);Ct(n,t,r,i)}Fe(t)}a(Ge,"processExemptions");function We(e){let{policyMap:t}=_e();W.Log.debug(`Removing policy exemptions for ${e.metadata?.name}`);for(let o of e.spec?.exemptions??[])for(let r of o.policies){let n=(t.get(r)||[]).filter(s=>{if(!$(s,{...o.matcher,owner:e.metadata?.uid||""}))return s});t.set(r,n)}Fe(t)}a(We,"removeExemptions");var x=require("pepr");var O="istio-injection",xe="uds.dev/original-istio-injection";async function Ke(e){if(!e.metadata?.namespace||!e.metadata.name)throw new Error("Invalid Package definition, missing namespace or name");let t=await(0,x.K8s)(x.kind.Namespace).Get(e.metadata.namespace),o=t.metadata?.labels||{},r=t.metadata?.annotations||{},i=`uds.dev/pkg-${e.metadata.name}`;r[O]||(r[xe]=o[O]||"non-existent"),(!r[i]||o[O]!=="enabled")&&(o[O]="enabled",r[i]="true",await(0,x.K8s)(x.kind.Namespace).Apply({metadata:{name:e.metadata.namespace,labels:o,annotations:r}},{force:!0}),await Je(e.metadata.namespace,!0))}a(Ke,"enableInjection");async function ze(e){if(!e.metadata?.namespace||!e.metadata.name)throw new Error("Invalid Package definition, missing namespace or name");let t=await(0,x.K8s)(x.kind.Namespace).Get(e.metadata.namespace),o=t.metadata?.labels||{},r=t.metadata?.annotations||{};delete r[`uds.dev/pkg-${e.metadata.name}`],Object.keys(r).find(i=>i.startsWith("uds.dev/pkg-"))||(o[O]=r[xe],o[O]==="non-existent"&&delete o[O],delete r[xe]),await(0,x.K8s)(x.kind.Namespace).Apply({metadata:{name:e.metadata.namespace,labels:o,annotations:r}},{force:!0}),await Je(e.metadata.namespace,!1)}a(ze,"cleanupNamespace");async function Je(e,t){let o=await(0,x.K8s)(x.kind.Pod).InNamespace(e).Get(),r={};for(let i of o.items){if(i.metadata?.deletionTimestamp)continue;let n=i.spec?.containers?.find(l=>l.name==="istio-proxy");if(t&&n||!t&&!n)continue;let s=i.metadata?.ownerReferences?.find(l=>l.controller)?.uid||"other";r[s]=r[s]||[],r[s].push(i)}for(let i of Object.values(r)){i[0].metadata?.ownerReferences?.find(n=>n.kind==="DaemonSet")&&i.sort((n,s)=>(s.metadata?.name||"").localeCompare(n.metadata?.name||""));for(let n of i)x.Log.info(`Deleting pod ${e}/${n.metadata?.name} to enable the istio sidecar`),await(0,x.K8s)(x.kind.Pod).Delete(n)}}a(Je,"killPods");var h=require("pepr");var Pe=require("pepr"),oe=process.env.UDS_DOMAIN;(!oe||oe==="###ZARF_VAR_DOMAIN###")&&(oe="uds.dev");var R={domain:oe,isSingleTest:process.env.UDS_SINGLE_TEST==="true",allowAllNSExemptions:process.env.UDS_ALLOW_ALL_NS_EXEMPTIONS==="true"};Pe.Log.info(R,"Loaded UDS Config");R.isSingleTest&&Pe.Log.warn("Running in single test mode, this will change the behavior of the operator and should only be used for UDS Core development testing.");function j(e){return e.toLowerCase().replace(/[^a-z0-9]+/g,"-").slice(0,250).replace(/^[^a-z]+|[^a-z]+$/g,"")}a(j,"sanitizeResourceName");function H(e){let{name:t,uid:o}=e.metadata;return[{apiVersion:e.apiVersion,kind:e.kind,uid:o,name:t}]}a(H,"getOwnerRef");var At="http://keycloak-http.keycloak.svc.cluster.local:8080/realms/uds/clients-registrations/default",Nt=new RegExp('clientField\\(([a-zA-Z]+)\\)(?:\\["?([\\w]+)"?\\]|(\\.json\\(\\)))?',"gm");async function Be(e){let t=e.spec?.sso||[],o=[];for(let r of t){let i=await Qe(r,e);o.push(i)}return await be(e,o),o}a(Be,"keycloak");async function be(e,t=[]){let r=(e.status?.ssoClients||[]).filter(i=>!t.includes(i));for(let i of r){let n=_.getItem(i),s=i.replace("sso-client-","");n?(_.removeItem(i),await we({clientId:s},"DELETE",n)):h.Log.warn(e.metadata,`Failed to remove client ${s}, token not found`)}}a(be,"purgeSSOClients");async function Qe({isAuthSvcClient:e,secretName:t,secretTemplate:o,...r},i,n=!1){h.Log.debug(i.metadata,`Processing client request: ${r.clientId}`);try{let s=`sso-client-${r.clientId}`,l=_.getItem(s),d;return l&&!n?(h.Log.debug(i.metadata,`Found existing token for ${r.clientId}`),d=await we(r,"PUT",l)):(h.Log.debug(i.metadata,`Creating new client for ${r.clientId}`),d=await we(r)),await _.setItemAndWait(s,d.registrationAccessToken),delete d.registrationAccessToken,await(0,h.K8s)(h.kind.Secret).Apply({metadata:{namespace:i.metadata.namespace,name:t||s,labels:{"uds/package":i.metadata.name},ownerReferences:H(i)},data:It(d,o)}),s}catch(s){let l=`Failed to process client request '${r.clientId}' for ${i.metadata?.namespace}/${i.metadata?.name}. This can occur if a client already exists with the same ID that Pepr isn't tracking.`;if(h.Log.error({err:s},l),n)throw h.Log.error(`${l}, retry failed, aborting`),new Error(`${l}. RETRY FAILED, aborting: ${JSON.stringify(s)}`);return h.Log.warn(`${l}, retrying`),Qe(r,i,!0)}}a(Qe,"syncClient");async function we(e,t="POST",o=""){if(R.isSingleTest)return h.Log.warn(`Generating fake client for '${e.clientId}' in single test mode`),{...e,secret:e.secret||"fake-secret",registrationAccessToken:"fake-registration-access-token"};let r={body:JSON.stringify(e),method:t,headers:{"Content-Type":"application/json"}},i=At;o&&(r.headers.Authorization=`Bearer ${o}`,i+=`/${e.clientId}`),t==="DELETE"&&delete r.body;let n=await(0,h.fetch)(i,r);if(!n.ok)throw new Error(`Failed to ${t} client: ${n.statusText}`);return n.data}a(we,"apiCall");function It(e,t){if(t)return h.Log.debug(`Using secret template for client: ${e.clientId}`),Et(t,e);let o={};h.Log.debug(`Using client data for secret: ${e.clientId}`);for(let[r,i]of Object.entries(e)){let n=typeof i=="object"?JSON.stringify(i):String(i);o[r]=Buffer.from(n).toString("base64")}return o}a(It,"generateSecretData");function Et(e,t){let o={};for(let[r,i]of Object.entries(e)){let n=i.replace(Nt,(s,l,d,c)=>{let p=t[l];return d?String(p[d]??""):c?JSON.stringify(p):p!==void 0?String(p):""});o[r]=Buffer.from(n).toString("base64")}return o}a(Et,"templateData");var u=require("pepr");var Se="169.254.169.254/32",Ze=[{ipBlock:{cidr:Se}}];var ie={ipBlock:{cidr:"0.0.0.0/0",except:[Se]}};var K;async function Xe(){let e=await(0,u.K8s)(u.kind.EndpointSlice).InNamespace("default").Get("kubernetes"),t=await(0,u.K8s)(u.kind.Service).InNamespace("default").Get("kubernetes");await ve(e,t)}a(Xe,"initAPIServerCIDR");function Ye(){return K||(u.Log.warn("Unable to get API server CIDR, defaulting to 0.0.0.0/0"),[ie])}a(Ye,"kubeAPI");async function qe(e){let t=await(0,u.K8s)(u.kind.Service).InNamespace("default").Get("kubernetes");await ve(e,t)}a(qe,"updateAPIServerCIDRFromEndpointSlice");async function et(e){let t=await(0,u.K8s)(u.kind.EndpointSlice).InNamespace("default").Get("kubernetes");await ve(t,e)}a(et,"updateAPIServerCIDRFromService");async function ve(e,t){let{endpoints:o}=e,r=t.spec?.clusterIP,i=o?.flatMap(n=>n.addresses);if(r&&i?.push(r),i?.length){K=i.flatMap(s=>({ipBlock:{cidr:`${s}/32`}}));let n=await(0,u.K8s)(u.kind.NetworkPolicy).WithLabel("uds.dev/generated","KubeAPI").Get();for(let s of n.items){let l=s.spec?.egress?.[0].to;u.R.equals(l,K)||(s.spec.egress[0].to=K,u.Log.debug(`Updating ${s.metadata.namespace}/${s.metadata.name}`),await(0,u.K8s)(u.kind.NetworkPolicy).Apply(s))}}}a(ve,"updateAPIServerCIDR");function Ut(e){return e[0]==="/"&&e[e.length-1]==="/"}a(Ut,"checkForSlashes");var tt="uds-policy-exemptions",Ot=new Map([["pod",Object.values(D).filter(e=>e!="DisallowNodePortServices"&&e!="RestrictExternalNames")],["service",["RestrictExternalNames","DisallowNodePortServices"]]]);async function rt(e){let t=e.Raw,o=t.spec?.exemptions??[];if(!R.allowAllNSExemptions&&t.metadata?.namespace!==tt)return e.Deny(`Invalid namespace "${t.metadata?.namespace}" for UDSExemption ${t.metadata?.name}: must be "${tt}"`);if(o.length===0)return e.Deny("Invalid number of exemptions: must have at least 1");for(let r of o){let i=Ot.get(r.matcher.kind);for(let n of r.policies)if(!i.includes(n)){let s=r.matcher.kind==="pod"?"service":"pod";return e.Deny(`Invalid kind "${r.matcher.kind}" for matcher "${r.matcher.name}" with policy "${n}": "${n}" can only be exempted for kind "${s}"`)}}for(let r of o){if(Ut(r.matcher.name))return e.Deny(`Invalid matcher name "${r.matcher.name}": please remove the leading and trailing slashes`);try{new RegExp(r.matcher.name)}catch(i){return e.Deny(`Invalid regular expression pattern ${r.matcher.name}: ${i}`)}}return e.Approve()}a(rt,"exemptValidator");var M=require("pepr");async function ot(e,t){let o=e.metadata.name,r=(e.metadata?.generation??0).toString(),i=e.spec?.network?.expose??[],n=[];for(let d of i){let{gateway:c="tenant",host:p,port:F,service:z,advancedHTTP:J={}}=d,m=Re(e,d),pe=(c==="admin"?"admin.":"")+R.domain,De=`${p}.${pe}`,Ce={...J},Ae=[{destination:{host:`${z}.${t}.svc.cluster.local`,port:{number:F}}}];J.directResponse||(Ce.route=Ae);let B={metadata:{name:m,namespace:t,labels:{"uds/package":o,"uds/generation":r},ownerReferences:H(e)},spec:{hosts:[De],gateways:[`istio-${c}-gateway/${c}-gateway`],http:[Ce]}};c==="passthrough"&&(B.spec.tls=[{match:[{port:443,sniHosts:[De]}],route:Ae}]),M.Log.debug(B,`Applying VirtualService ${m}`),await(0,M.K8s)(V.VirtualService).Apply(B,{force:!0}),n.push(B)}let l=(await(0,M.K8s)(V.VirtualService).InNamespace(t).WithLabel("uds/package",o).Get()).items.filter(d=>d.metadata?.labels?.["uds/generation"]!==r);for(let d of l)M.Log.debug(d,`Deleting orphaned VirtualService ${d.metadata.name}`),await(0,M.K8s)(V.VirtualService).Delete(d);return[...new Set(n.map(d=>d.spec.hosts).flat())]}a(ot,"virtualService");function Re(e,t){let{gateway:o="tenant",host:r,port:i,service:n,description:s,advancedHTTP:l}=t,d=l?.match?.flatMap(F=>F.name).join("-")||"",c=s||`${r}-${i}-${n}-${d}`;return j(`${e.metadata.name}-${o}-${c}`)}a(Re,"generateVSName");var it={podSelector:{matchLabels:{}}};function N(e,t){let r={apiVersion:"networking.k8s.io/v1",kind:"NetworkPolicy",metadata:{name:ke(t),namespace:e,labels:{...t.labels}},spec:{policyTypes:[t.direction],podSelector:{matchLabels:t.selector}}};t.description&&(r.metadata.annotations={"uds/description":t.description});let i=[];if(t.remoteNamespace!==void 0){let s={};t.remoteNamespace!==""&&t.remoteNamespace!=="*"&&(s.matchLabels={"kubernetes.io/metadata.name":t.remoteNamespace}),i.push({namespaceSelector:s})}if(t.remoteSelector&&i.push({podSelector:{matchLabels:t.remoteSelector}}),t.remoteGenerated)switch(r.metadata.labels["uds/generated"]=t.remoteGenerated,t.remoteGenerated){case"KubeAPI":i=Ye();break;case"CloudMetadata":i=Ze;break;case"IntraNamespace":i.push(it);break;case"Anywhere":i=[ie];break}let n=(t.ports??[]).map(s=>({port:s}));switch(t.port&&n.push({port:t.port}),t.direction){case"Ingress":r.spec.ingress=[{from:i,ports:n}];break;case"Egress":r.spec.egress=[{to:i,ports:n}];break}return r}a(N,"generate");function ke(e){let t=e.description||[Object.values(e.selector||["all pods"]),e.remoteGenerated||[e.remoteNamespace,Object.values(e.remoteSelector||["all pods"])]].flat(1).join("-");return`${e.direction}-${t}`}a(ke,"generateName");function ne(e){let t=e.spec?.network?.expose??[];for(let r of t)r.match&&(r.advancedHTTP=r.advancedHTTP??{},r.advancedHTTP.match=r.match,delete r.match);let o=e.spec?.network?.allow??[];for(let r of o)r.podLabels&&(r.selector=r.podLabels,delete r.podLabels),r.remotePodLabels&&(r.remoteSelector=r.remotePodLabels,delete r.remotePodLabels);return e}a(ne,"migrate");var Mt=["kube-system","kube-public","_unknown_","pepr-system"];async function nt(e){let t=ne(e.Raw),o=t.metadata?.namespace??"_unknown_";if(Mt.includes(o))return e.Deny("invalid namespace");let r=t.spec?.network?.expose??[],i=new Set;for(let c of r){if(c.gateway==="passthrough"&&c.advancedHTTP)return e.Deny("advancedHTTP cannot be used with passthrough gateway");if(c.advancedHTTP?.directResponse&&(c.service||c.selector||c.port||c.targetPort))return e.Deny("directResponse cannot be combined with service, port, selector, targetPort");let p=Re(e.Raw,c);if(i.has(p))return e.Deny(`The combination of characteristics of this expose entry would create a duplicate VirtualService. Verify you do not have duplicate values, or add a unique "description" field for this rule. The duplicate rule would be named "${p}".`);i.add(p)}let n=t.spec?.network?.allow??[],s=new Set;for(let c of n){if(c.remoteGenerated&&(c.remoteNamespace||c.remoteSelector))return e.Deny("remoteGenerated cannot be combined with remoteNamespace or remoteSelector");let p=j(`allow-${t.metadata?.name}-${ke(c)}`);if(s.has(p))return e.Deny(`The combination of characteristics of this network allow rule would create a duplicate NetworkPolicy. Verify you do not have duplicate allow rules, or add a unique "description" field for this rule. The duplicate rule would be named "${p}".`);s.add(p)}let l=t.spec?.sso??[],d=new Set;for(let c of l){if(d.has(c.clientId))return e.Deny(`The client ID "${c.clientId}" is not unique`);d.add(c.clientId)}return e.Approve()}a(nt,"validator");var ct=require("pepr");var P=require("pepr");var at=new Set;function ae(e){let t=e.status?.phase==="Pending",o=e.metadata?.generation===e.status?.observedGeneration;return at.has(e.metadata.uid)?t||o?(P.Log.debug(e,"Should skip? Yes, pending or current generation and not first time seen"),!0):(P.Log.debug(e,"Should skip? No, not pending or current generation and not first time seen"),!1):(P.Log.debug(e,"Should skip? No, first time processed during this pod's lifetime"),at.add(e.metadata.uid),!1)}a(ae,"shouldSkip");async function L(e,t){let o=e.kind==="Package"?k:T;P.Log.debug(e.metadata,`Updating status to ${t.phase}`),await(0,P.K8s)(o).PatchStatus({metadata:{name:e.metadata.name,namespace:e.metadata.namespace},status:t})}a(L,"updateStatus");async function st(e,t){P.Log.debug(e.metadata,`Writing event: ${t.message}`),await(0,P.K8s)(P.kind.CoreEvent).Create({type:"Warning",reason:"ReconciliationFailed",...t,metadata:{namespace:e.metadata.namespace,generateName:e.metadata.name},involvedObject:{apiVersion:e.apiVersion,kind:e.kind,name:e.metadata.name,namespace:e.metadata.namespace,uid:e.metadata.uid},firstTimestamp:new Date,reportingComponent:"uds.dev/operator",reportingInstance:process.env.HOSTNAME})}a(st,"writeEvent");async function se(e,t){let o=t.metadata,r=`${o.namespace}/${o.name}`;if(e.status===404){P.Log.warn({err:e},"Package metadata seems to have been deleted");return}P.Log.error({err:e},`Error configuring ${r}`);let i={phase:"Failed",observedGeneration:o.generation};st(t,{message:e.message}),L(t,i).catch(n=>{P.Log.error({err:n},`Error updating status for ${r} failed`),st(t,{message:n.message})})}a(se,"handleFailure");async function pt(e){if(ae(e))return;let t=e.metadata,{namespace:o,name:r}=t;ct.Log.debug(e,`Processing Exemption ${o}/${r}`);try{await L(e,{phase:"Pending"}),Ge(e),await L(e,{phase:"Ready",observedGeneration:t.generation,titles:e.spec?.exemptions?.map(i=>i.title||i.matcher.name)})}catch(i){se(i,e)}}a(pt,"exemptReconciler");var ce=require("pepr");var v=require("pepr");var dt=a(e=>{let t=N(e,{direction:"Egress",description:"DNS lookup via CoreDNS",remoteNamespace:"kube-system",remoteSelector:{"k8s-app":"kube-dns"},port:53});return t.spec.egress[0].ports[0].protocol="UDP",t},"allowEgressDNS");var lt=a(e=>N(e,{direction:"Egress",description:"Istiod communication",remoteNamespace:"istio-system",remoteSelector:{istio:"pilot"},port:15012}),"allowEgressIstiod");var mt=a(e=>N(e,{direction:"Ingress",description:"Sidecar monitoring",remoteNamespace:"monitoring",remoteSelector:{app:"prometheus"},port:15020}),"allowIngressSidecarMonitoring");function ut(e){return{apiVersion:"networking.k8s.io/v1",kind:"NetworkPolicy",metadata:{name:"default",namespace:e},spec:{podSelector:{},policyTypes:["Ingress","Egress"],ingress:[],egress:[]}}}a(ut,"defaultDenyAll");async function ft(e,t){let o=e.spec?.network?.allow??[],r=e.metadata.name,i=(e.metadata?.generation??0).toString();v.Log.debug(e.metadata,`Generating NetworkPolicies for generation ${i}`);let n=[ut(t),dt(t),lt(t),mt(t)];for(let c of o){let p=N(t,c);n.push(p)}let s=e.spec?.network?.expose??[];for(let c of s.filter(p=>!p.advancedHTTP?.directResponse)){let{gateway:p="tenant",port:F,selector:z={},targetPort:J}=c,m={direction:"Ingress",selector:z,remoteNamespace:`istio-${p}-gateway`,remoteSelector:{app:`${p}-ingressgateway`},port:J??F,description:`${Object.values(z)} Istio ${p} gateway`},pe=N(t,m);n.push(pe)}for(let[c,p]of n.entries())p.metadata=p.metadata??{},p.metadata.labels=p.metadata?.labels??{},p.metadata.labels["uds/package"]=r,p.metadata.labels["uds/generation"]=i,c<1?p.metadata.name=`deny-${r}-${p.metadata.name}`:p.metadata.name=`allow-${r}-${p.metadata.name}`,p.metadata.name=j(p.metadata.name),p.metadata.ownerReferences=H(e),await(0,v.K8s)(v.kind.NetworkPolicy).Apply(p,{force:!0});let d=(await(0,v.K8s)(v.kind.NetworkPolicy).InNamespace(t).WithLabel("uds/package",r).Get()).items.filter(c=>c.metadata?.labels?.["uds/generation"]!==i);for(let c of d)v.Log.debug(c,`Deleting orphaned NetworkPolicy ${c.metadata.name}`),await(0,v.K8s)(v.kind.NetworkPolicy).Delete(c);return n}a(ft,"networkPolicies");async function gt(e){let t=e.metadata,{namespace:o,name:r}=t;if(ce.Log.info(e,`Processing Package ${o}/${r}`),ae(e)){ce.Log.info(e,`Skipping Package ${o}/${r}`);return}ne(e);try{await L(e,{phase:"Pending"});let i=await ft(e,o),n=[];R.isSingleTest?ce.Log.warn(`Running in single test mode, skipping ${r} VirtualService.`):(await Ke(e),n=await ot(e,o));let s=await Be(e);await L(e,{phase:"Ready",ssoClients:s,endpoints:n,networkPolicyCount:i.length,observedGeneration:t.generation})}catch(i){se(i,e)}}a(gt,"packageReconciler");Xe();I(Te.a.EndpointSlice).IsCreatedOrUpdated().InNamespace("default").WithName("kubernetes").Watch(qe);I(Te.a.Service).IsCreatedOrUpdated().InNamespace("default").WithName("kubernetes").Watch(et);I(k).IsDeleted().Watch(async e=>{await ze(e),await be(e,[])});I(k).IsCreatedOrUpdated().Validate(nt).Reconcile(gt);I(T).IsDeleted().Watch(We);I(T).IsCreatedOrUpdated().Validate(rt).Reconcile(pt);new yt.PeprModule(Ie,[X,E,le]);
//# sourceMappingURL=pepr-uds-core.js.map
