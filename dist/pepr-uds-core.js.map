{
  "version": 3,
  "sources": ["../pepr.ts", "../package.json", "../src/pepr/istio/index.ts", "../src/pepr/operator/index.ts", "../src/pepr/operator/common.ts", "../src/pepr/operator/crd/register.ts", "../src/pepr/operator/crd/sources/exemption/v1alpha1.ts", "../src/pepr/operator/crd/sources/istio/virtualservice-v1beta1.ts", "../src/pepr/operator/crd/sources/package/v1alpha1.ts", "../src/pepr/operator/controllers/exemptions/exemptions.ts", "../src/pepr/policies/security.ts", "../src/pepr/operator/crd/generated/package-v1alpha1.ts", "../src/pepr/operator/crd/generated/exemption-v1alpha1.ts", "../src/pepr/operator/crd/generated/istio/virtualservice-v1beta1.ts", "../src/pepr/policies/common.ts", "../src/pepr/policies/exemptions/index.ts", "../src/pepr/policies/storage.ts", "../src/pepr/policies/networking.ts", "../src/pepr/operator/controllers/istio/injection.ts", "../src/pepr/operator/controllers/keycloak/client-sync.ts", "../src/pepr/config.ts", "../src/pepr/operator/controllers/utils.ts", "../src/pepr/operator/controllers/network/generators/kubeAPI.ts", "../src/pepr/operator/controllers/network/generators/cloudMetadata.ts", "../src/pepr/operator/controllers/network/generators/anywhere.ts", "../src/pepr/operator/crd/validators/exempt-validator.ts", "../src/pepr/operator/controllers/istio/virtual-service.ts", "../src/pepr/operator/controllers/network/generators/intraNamespace.ts", "../src/pepr/operator/controllers/network/generate.ts", "../src/pepr/operator/crd/migrate.ts", "../src/pepr/operator/crd/validators/package-validator.ts", "../src/pepr/operator/reconcilers/exempt-reconciler.ts", "../src/pepr/operator/reconcilers/index.ts", "../src/pepr/operator/reconcilers/package-reconciler.ts", "../src/pepr/operator/controllers/network/policies.ts", "../src/pepr/operator/controllers/network/defaults/allow-egress-dns.ts", "../src/pepr/operator/controllers/network/defaults/allow-egress-istiod.ts", "../src/pepr/operator/controllers/network/defaults/allow-ingress-sidecar-monitoring.ts", "../src/pepr/operator/controllers/network/defaults/default-deny-all.ts"],
  "sourcesContent": ["import { PeprModule } from \"pepr\";\n\nimport cfg from \"./package.json\";\n\nimport { istio } from \"./src/pepr/istio\";\nimport { operator } from \"./src/pepr/operator\";\nimport { policies } from \"./src/pepr/policies\";\n\nnew PeprModule(cfg, [\n  // UDS Core Operator\n  operator,\n\n  // UDS Core Policies\n  policies,\n\n  // Istio service mesh\n  istio,\n]);\n", "{\n  \"name\": \"uds-core\",\n  \"version\": \"0.4.0\",\n  \"description\": \"A collection of capabilities for UDS Core\",\n  \"keywords\": [\n    \"pepr\",\n    \"k8s\",\n    \"policy-engine\",\n    \"pepr-module\",\n    \"security\"\n  ],\n  \"engines\": {\n    \"node\": \">=20.0.0\"\n  },\n  \"pepr\": {\n    \"name\": \"UDS Core\",\n    \"uuid\": \"uds-core\",\n    \"onError\": \"reject\",\n    \"logLevel\": \"debug\",\n    \"alwaysIgnore\": {\n      \"namespaces\": [\n        \"uds-dev-stack\",\n        \"zarf\"\n      ],\n      \"labels\": []\n    },\n    \"env\": {\n      \"UDS_DOMAIN\": \"###ZARF_VAR_DOMAIN###\",\n      \"UDS_ALLOW_ALL_NS_EXEMPTIONS\": \"###ZARF_VAR_ALLOW_ALL_NS_EXEMPTIONS###\",\n      \"UDS_SINGLE_TEST\": \"###ZARF_VAR_UDS_SINGLE_TEST###\"\n    }\n  },\n  \"scripts\": {\n    \"k3d-setup\": \"k3d cluster delete pepr-dev && k3d cluster create pepr-dev --k3s-arg '--debug@server:0'\"\n  },\n  \"dependencies\": {\n    \"pepr\": \"0.28.7\"\n  },\n  \"devDependencies\": {\n    \"@jest/globals\": \"29.7.0\",\n    \"jest\": \"29.7.0\",\n    \"ts-jest\": \"29.1.2\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"testEnvironment\": \"node\",\n    \"globalSetup\": \"./jest.setup.js\",\n    \"globalTeardown\": \"./jest.teardown.js\"\n  }\n}\n", "import { Exec, KubeConfig } from \"@kubernetes/client-node\";\nimport { Capability, Log, a } from \"pepr\";\n\nexport const istio = new Capability({\n  name: \"istio\",\n  description: \"UDS Core Capability for Istio service mesh.\",\n});\n\nconst { When } = istio;\n\n// Keep track of in-progress terminations\nconst inProgress = new Set<string>();\n\n/**\n * Watch Pods with the \"batch.kubernetes.io/job-name\" and \"service.istio.io/canonical-name\" labels\n * to terminate the sidecar after the job completes successfully.\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .WithLabel(\"batch.kubernetes.io/job-name\")\n  .WithLabel(\"service.istio.io/canonical-name\")\n  .Watch(async pod => {\n    Log.info(\n      pod,\n      `Processing Pod ${pod.metadata?.namespace}/${pod.metadata?.name} for istio job termination`,\n    );\n\n    if (!pod.metadata?.name || !pod.metadata.namespace) {\n      Log.error(pod, `Invalid Pod definition`);\n      return;\n    }\n\n    const { name, namespace } = pod.metadata;\n    const key = `${namespace}/${name}`;\n\n    // Ensure termination isn't already in progress\n    if (inProgress.has(key)) {\n      return;\n    }\n\n    // Only terminate if the pod is running\n    if (pod.status?.phase == \"Running\") {\n      // Check all container statuses\n      if (!pod.status.containerStatuses) {\n        Log.error(pod, `Invalid container status in Pod`);\n        return;\n      }\n      const shouldTerminate = pod.status.containerStatuses\n        // Ignore the istio-proxy container\n        .filter(c => c.name != \"istio-proxy\")\n        // and if ALL are terminated AND have exit code 0, then shouldTerminate is true\n        .every(c => c.state?.terminated && c.state.terminated.exitCode == 0);\n\n      if (shouldTerminate) {\n        // Mark the pod as seen\n        inProgress.add(key);\n\n        Log.info(`Attempting to terminate sidecar for ${key}`);\n        try {\n          const kc = new KubeConfig();\n          kc.loadFromDefault();\n          const exec = new Exec(kc);\n\n          await exec.exec(\n            namespace,\n            name,\n            \"istio-proxy\",\n            [\"pilot-agent\", \"request\", \"POST\", \"/quitquitquit\"],\n            null, // Could capture exec stdout here\n            null, // Could capture exec stderr here\n            process.stdin,\n            true,\n          );\n\n          Log.info(`Terminated sidecar for ${key}`);\n        } catch (err) {\n          Log.error({ err }, `Failed to terminate the sidecar for ${key}`);\n\n          // Remove the pod from the seen list\n          inProgress.delete(key);\n        }\n      }\n    }\n  });\n", "// Common imports\nimport { a } from \"pepr\";\nimport { When } from \"./common\";\n\n// Controller imports\nimport { removeExemptions } from \"./controllers/exemptions/exemptions\";\nimport { cleanupNamespace } from \"./controllers/istio/injection\";\nimport { purgeSSOClients } from \"./controllers/keycloak/client-sync\";\nimport {\n  initAPIServerCIDR,\n  updateAPIServerCIDRFromEndpointSlice,\n  updateAPIServerCIDRFromService,\n} from \"./controllers/network/generators/kubeAPI\";\n\n// CRD imports\nimport { UDSExemption, UDSPackage } from \"./crd\";\nimport { exemptValidator } from \"./crd/validators/exempt-validator\";\nimport { validator } from \"./crd/validators/package-validator\";\n\n// Reconciler imports\nimport { exemptReconciler } from \"./reconcilers/exempt-reconciler\";\nimport { packageReconciler } from \"./reconcilers/package-reconciler\";\n\n// Export the operator capability for registration in the root pepr.ts\nexport { operator } from \"./common\";\n\n// Pre-populate the API server CIDR since we are not persisting the EndpointSlice\n// Note ignore any errors since the watch will still be running hereafter\nvoid initAPIServerCIDR();\n\n// Watch for changes to the API server EndpointSlice and update the API server CIDR\nWhen(a.EndpointSlice)\n  .IsCreatedOrUpdated()\n  .InNamespace(\"default\")\n  .WithName(\"kubernetes\")\n  .Watch(updateAPIServerCIDRFromEndpointSlice);\n\n// Watch for changes to the API server Service and update the API server CIDR\nWhen(a.Service)\n  .IsCreatedOrUpdated()\n  .InNamespace(\"default\")\n  .WithName(\"kubernetes\")\n  .Watch(updateAPIServerCIDRFromService);\n\n// Watch for changes to the UDSPackage CRD and cleanup the namespace mutations\nWhen(UDSPackage)\n  .IsDeleted()\n  .Watch(async pkg => {\n    // Cleanup the namespace\n    await cleanupNamespace(pkg);\n\n    // Remove any SSO clients\n    await purgeSSOClients(pkg, []);\n  });\n\n// Watch for changes to the UDSPackage CRD to enqueue a package for processing\nWhen(UDSPackage)\n  .IsCreatedOrUpdated()\n  // Advanced CR validation\n  .Validate(validator)\n  // Enqueue the package for processing\n  .Reconcile(packageReconciler);\n\n//Watch for changes to the UDSExemption CRD and cleanup exemptions in policies Store\nWhen(UDSExemption).IsDeleted().Watch(removeExemptions);\n\n// Watch for changes to the UDSExemption CRD to enqueue an exemption for processing\nWhen(UDSExemption).IsCreatedOrUpdated().Validate(exemptValidator).Reconcile(exemptReconciler);\n", "import { Capability } from \"pepr\";\n\n// Register the CRD\nimport \"./crd/register\";\n\nexport const operator = new Capability({\n  name: \"uds-core-operator\",\n  description: \"The UDS Operator is responsible for managing the lifecycle of UDS resources\",\n});\n\nexport const { Store, When } = operator;\n", "import { K8s, Log, kind } from \"pepr\";\n\nimport { v1alpha1 as exemption } from \"./sources/exemption/v1alpha1\";\nimport { v1alpha1 as pkg } from \"./sources/package/v1alpha1\";\n\n// Register the CRD if we're in watch or dev mode\nif (process.env.PEPR_WATCH_MODE === \"true\" || process.env.PEPR_MODE === \"dev\") {\n  K8s(kind.CustomResourceDefinition)\n    .Apply(\n      {\n        apiVersion: \"apiextensions.k8s.io/v1\",\n        kind: \"CustomResourceDefinition\",\n        metadata: {\n          name: \"packages.uds.dev\",\n        },\n        spec: {\n          group: \"uds.dev\",\n          versions: [pkg],\n          scope: \"Namespaced\",\n          names: {\n            plural: \"packages\",\n            singular: \"package\",\n            kind: \"Package\",\n            shortNames: [\"pkg\"],\n          },\n        },\n      },\n      { force: true },\n    )\n    .then(() => {\n      Log.info(\"CRD registered\");\n    })\n    .catch(err => {\n      Log.error({ err }, \"Failed to register CRD\");\n\n      // Sad times, let's exit\n      process.exit(1);\n    });\n\n  K8s(kind.CustomResourceDefinition)\n    .Apply(\n      {\n        apiVersion: \"apiextensions.k8s.io/v1\",\n        kind: \"CustomResourceDefinition\",\n        metadata: {\n          name: \"exemptions.uds.dev\",\n        },\n        spec: {\n          group: \"uds.dev\",\n          versions: [exemption],\n          scope: \"Namespaced\",\n          names: {\n            plural: \"exemptions\",\n            singular: \"exemption\",\n            kind: \"Exemption\",\n            shortNames: [\"exempt\"],\n          },\n        },\n      },\n      { force: true },\n    )\n    .then(() => {\n      Log.info(\"Exemption CRD registered\");\n    })\n    .catch(err => {\n      Log.error(err);\n\n      // Sad times, let's exit\n      process.exit(1);\n    });\n}\n", "import { V1CustomResourceDefinitionVersion, V1JSONSchemaProps } from \"@kubernetes/client-node\";\n\nexport const v1alpha1: V1CustomResourceDefinitionVersion = {\n  name: \"v1alpha1\",\n  served: true,\n  storage: true,\n  additionalPrinterColumns: [\n    {\n      name: \"Status\",\n      type: \"string\",\n      description: \"The status of the exemption\",\n      jsonPath: \".status.phase\",\n    },\n    {\n      name: \"Exemptions\",\n      type: \"string\",\n      description: \"Titles of the exemptions\",\n      jsonPath: \".status.titles\",\n    },\n    {\n      name: \"Age\",\n      type: \"date\",\n      description: \"The age of the exemption\",\n      jsonPath: \".metadata.creationTimestamp\",\n    },\n  ],\n  subresources: {\n    status: {},\n  },\n  schema: {\n    openAPIV3Schema: {\n      type: \"object\",\n      properties: {\n        status: {\n          type: \"object\",\n          properties: {\n            observedGeneration: {\n              type: \"integer\",\n            },\n            phase: {\n              enum: [\"Pending\", \"Ready\", \"Failed\"],\n              type: \"string\",\n            },\n            titles: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n              },\n            },\n          },\n        } as V1JSONSchemaProps,\n        spec: {\n          type: \"object\",\n          properties: {\n            exemptions: {\n              type: \"array\",\n              description: \"Policy exemptions\",\n              items: {\n                type: \"object\",\n                required: [\"policies\", \"matcher\"],\n                properties: {\n                  title: {\n                    type: \"string\",\n                    description: \"title to give the exemption for reporting purposes\",\n                  },\n                  description: {\n                    type: \"string\",\n                    description: \"Reasons as to why this exemption is needed\",\n                  },\n                  policies: {\n                    description: \"A list of policies to override\",\n                    type: \"array\",\n                    items: {\n                      type: \"string\",\n                      enum: [\n                        \"DisallowHostNamespaces\",\n                        \"DisallowNodePortServices\",\n                        \"DisallowPrivileged\",\n                        \"DisallowSELinuxOptions\",\n                        \"DropAllCapabilities\",\n                        \"RequireNonRootUser\",\n                        \"RestrictCapabilities\",\n                        \"RestrictExternalNames\",\n                        \"RestrictHostPathWrite\",\n                        \"RestrictHostPorts\",\n                        \"RestrictProcMount\",\n                        \"RestrictSeccomp\",\n                        \"RestrictSELinuxType\",\n                        \"RestrictVolumeTypes\",\n                      ],\n                    },\n                  },\n                  matcher: {\n                    description: \"Resource to exempt (Regex allowed for name)\",\n                    type: \"object\",\n                    required: [\"namespace\", \"name\"],\n                    properties: {\n                      namespace: {\n                        type: \"string\",\n                      },\n                      name: {\n                        type: \"string\",\n                      },\n                      kind: {\n                        type: \"string\",\n                        enum: [\"pod\", \"service\"],\n                        default: \"pod\",\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        } as V1JSONSchemaProps,\n      },\n    },\n  },\n};\n", "import { V1JSONSchemaProps } from \"@kubernetes/client-node\";\n\nconst matchRequired = [{ required: [\"exact\"] }, { required: [\"prefix\"] }, { required: [\"regex\"] }];\nconst matchTemplate = {\n  oneOf: [\n    {\n      not: {\n        anyOf: matchRequired,\n      },\n    },\n    ...matchRequired,\n  ],\n  properties: {\n    exact: {\n      type: \"string\",\n    },\n    prefix: {\n      type: \"string\",\n    },\n    regex: {\n      description: \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n      type: \"string\",\n    },\n  },\n  type: \"object\",\n};\n\nexport const advancedHTTP: V1JSONSchemaProps = {\n  description: \"Advanced HTTP settings for the route.\",\n  properties: {\n    corsPolicy: {\n      description: \"Cross-Origin Resource Sharing policy (CORS).\",\n      properties: {\n        allowCredentials: {\n          description:\n            \"Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.\",\n          nullable: true,\n          type: \"boolean\",\n        },\n        allowHeaders: {\n          description: \"List of HTTP headers that can be used when requesting the resource.\",\n          items: {\n            type: \"string\",\n          },\n          type: \"array\",\n        },\n        allowMethods: {\n          description: \"List of HTTP methods allowed to access the resource.\",\n          items: {\n            type: \"string\",\n          },\n          type: \"array\",\n        },\n        allowOrigin: {\n          items: {\n            type: \"string\",\n          },\n          type: \"array\",\n        },\n        allowOrigins: {\n          description: \"String patterns that match allowed origins.\",\n          items: matchTemplate,\n          type: \"array\",\n        },\n        exposeHeaders: {\n          description: \"A list of HTTP headers that the browsers are allowed to access.\",\n          items: {\n            type: \"string\",\n          },\n          type: \"array\",\n        },\n        maxAge: {\n          description: \"Specifies how long the results of a preflight request can be cached.\",\n          type: \"string\",\n        },\n      },\n      type: \"object\",\n    },\n    directResponse: {\n      description:\n        \"A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\",\n      properties: {\n        body: {\n          description: \"Specifies the content of the response body.\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"string\"],\n                  },\n                  {\n                    required: [\"bytes\"],\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"string\"],\n            },\n            {\n              required: [\"bytes\"],\n            },\n          ],\n          properties: {\n            bytes: {\n              description: \"response body as base64 encoded bytes.\",\n              format: \"binary\",\n              type: \"string\",\n            },\n            string: {\n              type: \"string\",\n            },\n          },\n          type: \"object\",\n        },\n        status: {\n          description: \"Specifies the HTTP response status to be returned.\",\n          type: \"integer\",\n        },\n      },\n      required: [\"status\"],\n      type: \"object\",\n    },\n    headers: {\n      properties: {\n        request: {\n          properties: {\n            add: {\n              additionalProperties: {\n                type: \"string\",\n              },\n              type: \"object\",\n            },\n            remove: {\n              items: {\n                type: \"string\",\n              },\n              type: \"array\",\n            },\n            set: {\n              additionalProperties: {\n                type: \"string\",\n              },\n              type: \"object\",\n            },\n          },\n          type: \"object\",\n        },\n        response: {\n          properties: {\n            add: {\n              additionalProperties: {\n                type: \"string\",\n              },\n              type: \"object\",\n            },\n            remove: {\n              items: {\n                type: \"string\",\n              },\n              type: \"array\",\n            },\n            set: {\n              additionalProperties: {\n                type: \"string\",\n              },\n              type: \"object\",\n            },\n          },\n          type: \"object\",\n        },\n      },\n      type: \"object\",\n    },\n    match: {\n      description:\n        \"Match the incoming request based on custom rules. Not permitted when using the passthrough gateway.\",\n      items: {\n        properties: {\n          ignoreUriCase: {\n            description: \"Flag to specify whether the URI matching should be case-insensitive.\",\n            type: \"boolean\",\n          },\n          method: matchTemplate,\n          name: {\n            description: \"The name assigned to a match.\",\n            type: \"string\",\n          },\n          queryParams: {\n            additionalProperties: matchTemplate,\n            description: \"Query parameters for matching.\",\n            type: \"object\",\n          },\n          uri: matchTemplate,\n        },\n        required: [\"name\"],\n        type: \"object\",\n      },\n      type: \"array\",\n    },\n    rewrite: {\n      description: \"Rewrite HTTP URIs and Authority headers.\",\n      properties: {\n        authority: {\n          description: \"rewrite the Authority/Host header with this value.\",\n          type: \"string\",\n        },\n        uri: {\n          description: \"rewrite the path (or the prefix) portion of the URI with this value.\",\n          type: \"string\",\n        },\n        uriRegexRewrite: {\n          description: \"rewrite the path portion of the URI with the specified regex.\",\n          properties: {\n            match: {\n              description:\n                \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n              type: \"string\",\n            },\n            rewrite: {\n              description: \"The string that should replace into matching portions of original URI.\",\n              type: \"string\",\n            },\n          },\n          type: \"object\",\n        },\n      },\n      type: \"object\",\n    },\n    retries: {\n      description: \"Retry policy for HTTP requests.\",\n      properties: {\n        attempts: {\n          description: \"Number of retries to be allowed for a given request.\",\n          format: \"int32\",\n          type: \"integer\",\n        },\n        perTryTimeout: {\n          description:\n            \"Timeout per attempt for a given request, including the initial call and any retries.\",\n          type: \"string\",\n        },\n        retryOn: {\n          description: \"Specifies the conditions under which retry takes place.\",\n          type: \"string\",\n        },\n        retryRemoteLocalities: {\n          description: \"Flag to specify whether the retries should retry to other localities.\",\n          nullable: true,\n          type: \"boolean\",\n        },\n      },\n      type: \"object\",\n    },\n    weight: {\n      description:\n        \"Weight specifies the relative proportion of traffic to be forwarded to the destination.\",\n      format: \"int32\",\n      type: \"integer\",\n    },\n    timeout: {\n      description: \"Timeout for HTTP requests, default is disabled.\",\n      type: \"string\",\n    },\n  },\n  type: \"object\",\n};\n", "import { V1CustomResourceDefinitionVersion, V1JSONSchemaProps } from \"@kubernetes/client-node\";\n\nimport { advancedHTTP } from \"../istio/virtualservice-v1beta1\";\n\nconst allow = {\n  description: \"Allow specific traffic (namespace will have a default-deny policy)\",\n  type: \"array\",\n  items: {\n    type: \"object\",\n    required: [\"direction\"],\n    properties: {\n      labels: {\n        description: \"The labels to apply to the policy\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      description: {\n        type: \"string\",\n        description: \"A description of the policy, this will become part of the policy name\",\n      },\n      direction: {\n        description: \"The direction of the traffic\",\n        enum: [\"Ingress\", \"Egress\"],\n        type: \"string\",\n      },\n      selector: {\n        description:\n          \"Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all pods in the namespace\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      remoteNamespace: {\n        description:\n          \"The remote namespace to allow traffic to/from. Use * or empty string to allow all namespaces\",\n        type: \"string\",\n      },\n      remoteSelector: {\n        description: \"The remote pod selector labels to allow traffic to/from\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      remoteGenerated: {\n        description: \"Custom generated remote selector for the policy\",\n        type: \"string\",\n        enum: [\"KubeAPI\", \"IntraNamespace\", \"CloudMetadata\", \"Anywhere\"],\n      },\n      port: {\n        description: \"The port to allow (protocol is always TCP)\",\n        minimum: 1,\n        maximum: 65535,\n        type: \"number\",\n      },\n      ports: {\n        description: \"A list of ports to allow (protocol is always TCP)\",\n        type: \"array\",\n        items: {\n          minimum: 1,\n          maximum: 65535,\n          type: \"number\",\n        },\n      },\n      // Deprecated fields\n      podLabels: {\n        description: \"Deprecated: use selector\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      remotePodLabels: {\n        description: \"Deprecated: use remoteSelector\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n    },\n  } as V1JSONSchemaProps,\n} as V1JSONSchemaProps;\n\nconst expose = {\n  type: \"array\",\n  description: \"Expose a service on an Istio Gateway\",\n  items: {\n    type: \"object\",\n    required: [\"host\"],\n    anyOf: [\n      {\n        required: [\"service\", \"podLabels\", \"port\"],\n      },\n      {\n        required: [\"service\", \"selector\", \"port\"],\n      },\n      {\n        required: [\"advancedHTTP\"],\n      },\n    ],\n    properties: {\n      description: {\n        type: \"string\",\n        description:\n          \"A description of this expose entry, this will become part of the VirtualService name\",\n      },\n      host: {\n        description: \"The hostname to expose the service on\",\n        type: \"string\",\n      },\n      gateway: {\n        description: \"The name of the gateway to expose the service on (default: tenant)\",\n        enum: [\"admin\", \"tenant\", \"passthrough\"],\n        type: \"string\",\n        default: \"tenant\",\n      },\n      service: {\n        description: \"The name of the service to expose\",\n        type: \"string\",\n      },\n      port: {\n        description: \"The port number to expose\",\n        minimum: 1,\n        maximum: 65535,\n        type: \"number\",\n      },\n      selector: {\n        description:\n          \"Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all pods in the namespace\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      targetPort: {\n        description:\n          \"The service targetPort. This defaults to port and is only required if the service port is different from the target port (so the NetworkPolicy can be generated correctly).\",\n        minimum: 1,\n        maximum: 65535,\n        type: \"number\",\n      },\n      advancedHTTP,\n      // Deprecated field\n      match: {\n        description: \"Deprecated: use advancedHTTP.match\",\n        ...advancedHTTP.properties?.match,\n      },\n      podLabels: {\n        description: \"Deprecated: use selector\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n    },\n  } as V1JSONSchemaProps,\n} as V1JSONSchemaProps;\n\nconst sso = {\n  description: \"Create SSO client configurations\",\n  type: \"array\",\n  items: {\n    type: \"object\",\n    required: [\"clientId\", \"name\", \"redirectUris\"],\n    properties: {\n      isAuthSvcClient: {\n        description: \"If true, the client will generate a new Auth Service client as well\",\n        type: \"boolean\",\n        default: false,\n      },\n      secretName: {\n        description: \"The name of the secret to store the client secret\",\n        type: \"string\",\n      },\n      secretTemplate: {\n        description: \"A template for the generated secret\",\n        // Create a map of the secret data\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      clientId: {\n        description: \"The client identifier registered with the identity provider.\",\n        type: \"string\",\n      },\n      secret: {\n        description: \"The client secret. Typically left blank and auto-generated.\",\n        type: \"string\",\n      },\n      name: {\n        description: \"Specifies display name of the client\",\n        type: \"string\",\n      },\n      description: {\n        description:\n          \"A description for the client, can be a URL to an image to replace the login logo\",\n        type: \"string\",\n      },\n      rootUrl: {\n        description: \"Root URL appended to relative URLs\",\n        type: \"string\",\n      },\n      redirectUris: {\n        description:\n          \"Valid URI pattern a browser can redirect to after a successful login. Simple wildcards are allowed such as 'https://unicorns.uds.dev/*'\",\n        type: \"array\",\n        items: {\n          type: \"string\",\n        },\n        minItems: 1,\n      },\n      webOrigins: {\n        description:\n          \"Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does not include the '*' wildcard though. To permit all origins, explicitly add '*'.\",\n        type: \"array\",\n        items: {\n          type: \"string\",\n        },\n      },\n      enabled: {\n        description: \"Whether the SSO client is enabled\",\n        type: \"boolean\",\n        default: true,\n      },\n      alwaysDisplayInConsole: {\n        description:\n          \"Always list this client in the Account UI, even if the user does not have an active session.\",\n        type: \"boolean\",\n        default: false,\n      },\n      clientAuthenticatorType: {\n        description: \"The client authenticator type\",\n        type: \"string\",\n        enum: [\"client-secret\", \"client-jwt\"],\n      },\n      defaultClientScopes: {\n        description: \"Default client scopes\",\n        type: \"array\",\n        items: {\n          type: \"string\",\n        },\n      },\n    },\n  } as V1JSONSchemaProps,\n} as V1JSONSchemaProps;\n\nexport const v1alpha1: V1CustomResourceDefinitionVersion = {\n  name: \"v1alpha1\",\n  served: true,\n  storage: true,\n  additionalPrinterColumns: [\n    {\n      name: \"Status\",\n      type: \"string\",\n      description: \"The status of the package\",\n      jsonPath: \".status.phase\",\n    },\n    {\n      name: \"SSO Clients\",\n      type: \"string\",\n      description: \"SSO Clients created by the package\",\n      jsonPath: \".status.ssoClients\",\n    },\n    {\n      name: \"Endpoints\",\n      type: \"string\",\n      description: \"Service endpoints exposed by the package\",\n      jsonPath: \".status.endpoints\",\n    },\n    {\n      name: \"Network Policies\",\n      type: \"integer\",\n      description: \"The number of network policies created by the package\",\n      jsonPath: \".status.networkPolicyCount\",\n    },\n    {\n      name: \"Age\",\n      type: \"date\",\n      description: \"The age of the package\",\n      jsonPath: \".metadata.creationTimestamp\",\n    },\n  ],\n  subresources: {\n    status: {},\n  },\n  schema: {\n    openAPIV3Schema: {\n      type: \"object\",\n      properties: {\n        status: {\n          type: \"object\",\n          properties: {\n            observedGeneration: {\n              type: \"integer\",\n            },\n            phase: {\n              enum: [\"Pending\", \"Ready\", \"Failed\"],\n              type: \"string\",\n            },\n            ssoClients: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n              },\n            },\n            endpoints: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n              },\n            },\n            networkPolicyCount: {\n              type: \"integer\",\n            },\n          },\n        } as V1JSONSchemaProps,\n        spec: {\n          type: \"object\",\n          properties: {\n            network: {\n              type: \"object\",\n              description: \"Network configuration for the package\",\n              properties: {\n                expose,\n                allow,\n              },\n            },\n            sso,\n          },\n        } as V1JSONSchemaProps,\n      },\n    },\n  },\n};\n", "import { Log } from \"pepr\";\nimport { policies } from \"../../../policies/index\";\nimport { ExemptionElement, Matcher, Policy, UDSExemption } from \"../../crd\";\n\ntype StoredMatcher = Matcher & { owner: string };\ntype PolicyMap = Map<Policy, StoredMatcher[]>;\n\nconst isSame = (a: StoredMatcher, b: StoredMatcher) => {\n  return (\n    a.name === b.name && a.namespace === b.namespace && a.kind == b.kind && a.owner === b.owner\n  );\n};\n\nfunction addIfIncludesPolicy(\n  policy: Policy,\n  policyMap: PolicyMap,\n  exemptionEl: ExemptionElement,\n  ownerId: string,\n) {\n  const storedMatchers = policyMap.get(policy) ?? [];\n  const matcherToStore = {\n    ...exemptionEl.matcher,\n    owner: ownerId,\n  };\n  const isDuplicate = storedMatchers.some(sm => isSame(sm, matcherToStore));\n\n  // add if not already added to policy's exemption list\n  if (exemptionEl.policies.includes(policy) && !isDuplicate) {\n    policyMap.set(policy, [...storedMatchers, matcherToStore]);\n  }\n}\n\n// Delete a matcher from a policy if the policy has been removed from its policy list\nfunction deleteIfPolicyRemoved(\n  policy: Policy,\n  policyMap: PolicyMap,\n  exemptionEl: ExemptionElement,\n  ownerId: string,\n) {\n  const matcher = {\n    ...exemptionEl.matcher,\n    owner: ownerId,\n  };\n  const storedMatchers = policyMap.get(policy) ?? [];\n\n  if (storedMatchers.some(sm => isSame(sm, matcher)) && !exemptionEl.policies.includes(policy)) {\n    policyMap.set(\n      policy,\n      storedMatchers.filter(sm => {\n        if (!isSame(sm, matcher)) return sm;\n      }),\n    );\n    Log.debug(`Removing ${matcher.name} from ${policy}`);\n  }\n}\n\n// Delete matchers from the store if they no longer exist on a UDSExemption\nfunction deleteIfMatchersRemoved(\n  policy: Policy,\n  policyMap: PolicyMap,\n  currExemptMatchers: StoredMatcher[],\n  ownerId: string,\n) {\n  const policyMatchers = policyMap.get(policy) || [];\n\n  // Check stored matchers that have same owner ref as current UDSExemption\n  for (const pm of policyMatchers.filter(m => m.owner === ownerId)) {\n    let shouldBeRemoved = true;\n\n    // check if stored matcher exists in current list of UDSExemption matchers\n    for (const m of currExemptMatchers) {\n      if (isSame(pm, m)) {\n        shouldBeRemoved = false;\n      }\n    }\n\n    if (shouldBeRemoved) {\n      // get again incase matchers were updated on previous iteration\n      const updatedPolicyMatchers = policyMap.get(policy) || [];\n      policyMap.set(\n        policy,\n        updatedPolicyMatchers.filter(sm => {\n          if (!isSame(sm, pm)) return sm;\n        }),\n      );\n\n      Log.debug(`Removing ${pm.name} from ${policy}`);\n    }\n  }\n}\n\n// Iterate through local Map and update Store\nfunction updateStore(policyMap: PolicyMap) {\n  const { Store } = policies;\n  for (const [policy, matchers] of policyMap.entries()) {\n    Log.debug(`Updating uds policy ${policy} exemptions: ${JSON.stringify(matchers)}`);\n    Store.setItem(policy, JSON.stringify(matchers));\n  }\n}\n\nfunction setupPolicyMap() {\n  const { Store } = policies;\n  const policyMap: PolicyMap = new Map();\n  const policyList = Object.values(Policy);\n\n  for (const p of policyList) {\n    policyMap.set(p, JSON.parse(Store.getItem(p) || \"[]\"));\n  }\n\n  return { policyMap, policyList };\n}\n\n// Add Exemptions to Pepr store as \"policy\": \"[{...matcher, owner: uid}]\"\n//(Performance Optimization) Use local map to do aggregation before updating store\nexport function processExemptions(exempt: UDSExemption) {\n  const { policyMap, policyList } = setupPolicyMap();\n  const currExemptMatchers: StoredMatcher[] = [];\n  const ownerId = exempt.metadata?.uid || \"\";\n\n  // Iterate through all policies -- important for removing exemptions if CR is updated\n  for (const p of policyList) {\n    for (const e of exempt.spec?.exemptions ?? []) {\n      currExemptMatchers.push({\n        ...e.matcher,\n        owner: ownerId,\n      });\n\n      // Add if exemption has this policy in its list\n      addIfIncludesPolicy(p, policyMap, e, ownerId);\n\n      // Check if matcher no longer has this policy from previous CR version\n      deleteIfPolicyRemoved(p, policyMap, e, ownerId);\n    }\n\n    // Check if policy should no longer have this matcher from previous CR version\n    deleteIfMatchersRemoved(p, policyMap, currExemptMatchers, ownerId);\n  }\n\n  updateStore(policyMap);\n}\n\n//(Performance Optimization) Use local map to do aggregation before updating store\nexport function removeExemptions(exempt: UDSExemption) {\n  const { policyMap } = setupPolicyMap();\n\n  Log.debug(`Removing policy exemptions for ${exempt.metadata?.name}`);\n\n  // Loop through exemptions and remove matchers from policies in the local map\n  for (const e of exempt.spec?.exemptions ?? []) {\n    for (const p of e.policies) {\n      const matchers = policyMap.get(p) || [];\n      const filteredList = matchers.filter(m => {\n        if (!isSame(m, { ...e.matcher, owner: exempt.metadata?.uid || \"\" })) return m;\n      });\n      policyMap.set(p, filteredList);\n    }\n  }\n\n  updateStore(policyMap);\n}\n", "import { a } from \"pepr\";\n\nimport { V1SecurityContext } from \"@kubernetes/client-node\";\nimport { Policy } from \"../operator/crd\";\nimport {\n  When,\n  annotateMutation,\n  containers,\n  securityContextContainers,\n  securityContextMessage,\n} from \"./common\";\nimport { isExempt, markExemption } from \"./exemptions\";\n\n/**\n * This policy ensures that Pods do not allow privilege escalation.\n *\n * The `allowPrivilegeEscalation` field in a container's security context should either be undefined\n * or set to `false` to prevent potential security vulnerabilities.\n *\n * Running containers in privileged mode disables many security mechanisms and grants extensive\n * access to host resources, which can lead to security breaches.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-privilege-escalation.yaml\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-privileged-containers.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.DisallowPrivileged))\n  .Validate(request => {\n    if (isExempt(request, Policy.DisallowPrivileged)) {\n      return request.Approve();\n    }\n\n    const violations = securityContextContainers(request).filter(\n      c => c.ctx.allowPrivilegeEscalation || c.ctx.privileged,\n    );\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\n          \"Privilege escalation is disallowed\",\n          [\"allowPrivilegeEscalation = false\", \"privileged = false\"],\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Require Non-root User for Pods\n *\n * Following the least privilege principle, containers should not be run as root. This policy ensures\n * containers either have `runAsNonRoot` set to `true` or `runAsUser` > 0. It applies to security contexts\n * defined at both the Pod level and individual container levels (including initContainers and ephemeralContainers).\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/require-non-root-user.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(request => {\n    markExemption(Policy.RequireNonRootUser)(request);\n    if (request.HasAnnotation(`uds-core.pepr.dev/uds-core-policies.${Policy.RequireNonRootUser}`)) {\n      return;\n    }\n\n    const pod = request.Raw.spec!;\n    const metadata = request.Raw.metadata || {};\n\n    // Ensure the securityContext field is defined\n    pod.securityContext = pod.securityContext || {};\n\n    // Set the runAsUser field if it is defined in a label\n    const runAsUser = metadata.labels?.[\"uds/user\"];\n    if (runAsUser) {\n      pod.securityContext.runAsUser = parseInt(runAsUser);\n    }\n\n    // Set the runAsGroup field if it is defined in a label\n    const runAsGroup = metadata.labels?.[\"uds/group\"];\n    if (runAsGroup) {\n      pod.securityContext.runAsGroup = parseInt(runAsGroup);\n    }\n\n    // Set the fsGroup field if it is defined in a label\n    const fsGroup = metadata.labels?.[\"uds/fsgroup\"];\n    if (fsGroup) {\n      pod.securityContext.fsGroup = parseInt(fsGroup);\n    }\n\n    // Set the runAsNonRoot field to true if it is undefined\n    if (pod.securityContext.runAsNonRoot === undefined) {\n      pod.securityContext.runAsNonRoot = true;\n    }\n\n    // Set the runAsUser field to 1000 if it is undefined\n    if (pod.securityContext.runAsUser === undefined) {\n      pod.securityContext.runAsUser = 1000;\n    }\n\n    // Set the runAsGroup field to 1000 if it is undefined\n    if (pod.securityContext.runAsGroup === undefined) {\n      pod.securityContext.runAsGroup = 1000;\n    }\n\n    annotateMutation(request, Policy.RequireNonRootUser);\n  })\n  .Validate(request => {\n    if (isExempt(request, Policy.RequireNonRootUser)) {\n      return request.Approve();\n    }\n    // Check if running as root by checking if runAsNonRoot is false or runAsUser is 0\n    const isRoot = (ctx: Partial<V1SecurityContext>) => {\n      const isRunAsRoot = ctx.runAsNonRoot === false;\n      const isRunAsRootUser = ctx.runAsUser === 0;\n\n      return isRunAsRoot || isRunAsRootUser;\n    };\n\n    // Check pod securityContext\n    const podCtx = request.Raw.spec?.securityContext || {};\n    if (isRoot(podCtx)) {\n      return request.Deny(\"Pod level securityContext does not meet the non-root user requirement.\");\n    }\n\n    // Check container securityContext\n    const violations = securityContextContainers(request).filter(c => isRoot(c.ctx));\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\n          \"Unauthorized container securityContext. Containers must not run as root\",\n          [\"runAsNonRoot = false\", \"runAsUser > 0\"],\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Restrict Proc Mount in Pods\n *\n * The default /proc masks are set up to reduce the attack surface. This policy\n * ensures nothing but the specified procMount can be used. By default only \"Default\"\n * is allowed. Applies to all containers, initContainers, and ephemeralContainers in a Pod.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-proc-mount.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictProcMount))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictProcMount)) {\n      return request.Approve();\n    }\n    const authorized = [undefined, \"Default\"];\n\n    const violations = securityContextContainers(request).filter(\n      c => !authorized.includes(c.ctx.procMount),\n    );\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\"Unauthorized procMount type\", authorized, violations),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Restrict Seccomp in Pods\n *\n * The SecComp profile should not be explicitly set to Unconfined. This policy ensures\n * that the `seccompProfile.Type` is undefined or restricted to `RuntimeDefault` or\n * `Localhost`. Applies to Pods and all types of containers within them.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-seccomp.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictSeccomp))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictSeccomp)) {\n      return request.Approve();\n    }\n\n    const authorized = [undefined, \"RuntimeDefault\", \"Localhost\"];\n\n    // Check Pod level security context\n    const ctx = request.Raw.spec?.securityContext || {};\n    if (!authorized.includes(ctx.seccompProfile?.type)) {\n      return request.Deny(\n        securityContextMessage(\"Unauthorized pod seccomp profile type\", authorized, [{ ctx }]),\n      );\n    }\n\n    const violations = securityContextContainers(request).filter(\n      c => !authorized.includes(c.ctx.seccompProfile?.type),\n    );\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\n          \"Unauthorized container seccomp profile type\",\n          authorized,\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Disallow SELinux Options in Pods\n *\n * SELinux options can be used to escalate privileges. This policy ensures that the\n * `seLinuxOptions` user and role fields are set to undefined.\n * Applies to Pods and all types of containers within them.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-selinux-options.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.DisallowSELinuxOptions))\n  .Validate(request => {\n    if (isExempt(request, Policy.DisallowSELinuxOptions)) {\n      return request.Approve();\n    }\n\n    const seLinuxOptions = request.Raw.spec?.securityContext?.seLinuxOptions;\n    const authorized = [\"user: undefined\", \"role: undefined\"];\n\n    // Check Pod level security context\n    if (seLinuxOptions?.user || seLinuxOptions?.role) {\n      return request.Deny(\n        securityContextMessage(`Unauthorized pod SELinux Options`, authorized, [\n          { ctx: request.Raw.spec?.securityContext as V1SecurityContext },\n        ]),\n      );\n    }\n\n    // Check Container level security context\n    const violations = securityContextContainers(request).filter(\n      c => c.ctx.seLinuxOptions?.user || c.ctx.seLinuxOptions?.role,\n    );\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\"Unauthorized container SELinux Options\", authorized, violations),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Restrict SELinux Type in Pods\n *\n * SELinux options can be used to escalate privileges. This policy ensures that the\n * `seLinuxOptions` type field is set to either `container_t`, `container_init_t`, or\n * `container_kvm_t`. Applies to Pods and all types of containers within them.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-selinux-type.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictSELinuxType))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictSELinuxType)) {\n      return request.Approve();\n    }\n\n    const authorized = [undefined, \"container_t\", \"container_init_t\", \"container_kvm_t\"];\n\n    // Check Pod level security context\n    const podSeLinuxType = request.Raw.spec?.securityContext?.seLinuxOptions?.type;\n    if (!authorized.includes(podSeLinuxType)) {\n      return request.Deny(\n        securityContextMessage(\"Unauthorized pod SELinux type\", authorized, [\n          { ctx: request.Raw.spec?.securityContext as V1SecurityContext },\n        ]),\n      );\n    }\n\n    const violations = securityContextContainers(request).filter(\n      c => !authorized.includes(c.ctx.seLinuxOptions?.type),\n    );\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\"Unauthorized container SELinux type\", authorized, violations),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Drop All Capabilities in Pods\n *\n * This policy ensures that all containers, initContainers, and ephemeralContainers in a Pod\n * explicitly specify `drop: [\"ALL\"]` in their securityContext capabilities. Capabilities permit\n * privileged actions without giving full root access. Dropping all capabilities and only adding\n * back those that are required increases the security posture of the Pod.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/require-drop-all-capabilities.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(request => {\n    markExemption(Policy.DropAllCapabilities)(request);\n    if (request.HasAnnotation(`uds-core.pepr.dev/uds-core-policies.${Policy.RequireNonRootUser}`)) {\n      return;\n    }\n\n    // Always set drop: [\"ALL\"] for all containers\n    for (const container of containers(request)) {\n      container.securityContext = container.securityContext || {};\n      container.securityContext.capabilities = container.securityContext.capabilities || {};\n      container.securityContext.capabilities.drop = [\"ALL\"];\n    }\n    annotateMutation(request, Policy.DropAllCapabilities);\n  })\n  .Validate(request => {\n    if (isExempt(request, Policy.DropAllCapabilities)) {\n      return request.Approve();\n    }\n    const authorized = \"ALL\";\n\n    const violations = securityContextContainers(request).filter(c => {\n      return !c.ctx.capabilities?.drop?.includes(authorized);\n    });\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\n          \"Unauthorized container DROP capabilities in securityContext.capabilities.drop\",\n          [authorized],\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Restrict Capabilities in Pods\n *\n * This policy ensures that users cannot add additional capabilities beyond the allowed list to a Pod.\n * The allowed capability in this policy is 'NET_BIND_SERVICE'. The policy checks that the `add` field\n * in the `capabilities` of the `securityContext` for all containers, initContainers, and ephemeralContainers\n * contains only the allowed capability. This helps in preventing the escalation of privileges by restricting\n * the capabilities that can be added to a container.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-capabilities.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictCapabilities))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictCapabilities)) {\n      return request.Approve();\n    }\n    const authorized = [\"NET_BIND_SERVICE\"];\n\n    const violations = securityContextContainers(request).filter(\n      c => c.ctx?.capabilities?.add && !c.ctx?.capabilities.add.includes(authorized[0]),\n    );\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\n          \"Unauthorized container capabilities in securityContext.capabilities.add\",\n          authorized,\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n", "// This file is auto-generated by kubernetes-fluent-client, do not edit manually\n\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n\nexport class Package extends GenericKind {\n  spec?: Spec;\n  status?: Status;\n}\n\nexport interface Spec {\n  /**\n   * Network configuration for the package\n   */\n  network?: Network;\n  /**\n   * Create SSO client configurations\n   */\n  sso?: Sso[];\n}\n\n/**\n * Network configuration for the package\n */\nexport interface Network {\n  /**\n   * Allow specific traffic (namespace will have a default-deny policy)\n   */\n  allow?: Allow[];\n  /**\n   * Expose a service on an Istio Gateway\n   */\n  expose?: Expose[];\n}\n\nexport interface Allow {\n  /**\n   * A description of the policy, this will become part of the policy name\n   */\n  description?: string;\n  /**\n   * The direction of the traffic\n   */\n  direction: Direction;\n  /**\n   * The labels to apply to the policy\n   */\n  labels?: { [key: string]: string };\n  /**\n   * Deprecated: use selector\n   */\n  podLabels?: { [key: string]: string };\n  /**\n   * The port to allow (protocol is always TCP)\n   */\n  port?: number;\n  /**\n   * A list of ports to allow (protocol is always TCP)\n   */\n  ports?: number[];\n  /**\n   * Custom generated remote selector for the policy\n   */\n  remoteGenerated?: RemoteGenerated;\n  /**\n   * The remote namespace to allow traffic to/from. Use * or empty string to allow all\n   * namespaces\n   */\n  remoteNamespace?: string;\n  /**\n   * Deprecated: use remoteSelector\n   */\n  remotePodLabels?: { [key: string]: string };\n  /**\n   * The remote pod selector labels to allow traffic to/from\n   */\n  remoteSelector?: { [key: string]: string };\n  /**\n   * Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all\n   * pods in the namespace\n   */\n  selector?: { [key: string]: string };\n}\n\n/**\n * The direction of the traffic\n */\nexport enum Direction {\n  Egress = \"Egress\",\n  Ingress = \"Ingress\",\n}\n\n/**\n * Custom generated remote selector for the policy\n */\nexport enum RemoteGenerated {\n  Anywhere = \"Anywhere\",\n  CloudMetadata = \"CloudMetadata\",\n  IntraNamespace = \"IntraNamespace\",\n  KubeAPI = \"KubeAPI\",\n}\n\nexport interface Expose {\n  /**\n   * Advanced HTTP settings for the route.\n   */\n  advancedHTTP?: AdvancedHTTP;\n  /**\n   * A description of this expose entry, this will become part of the VirtualService name\n   */\n  description?: string;\n  /**\n   * The name of the gateway to expose the service on (default: tenant)\n   */\n  gateway?: Gateway;\n  /**\n   * The hostname to expose the service on\n   */\n  host: string;\n  /**\n   * Match the incoming request based on custom rules. Not permitted when using the\n   * passthrough gateway.\n   */\n  match?: ExposeMatch[];\n  /**\n   * Deprecated: use selector\n   */\n  podLabels?: { [key: string]: string };\n  /**\n   * The port number to expose\n   */\n  port?: number;\n  /**\n   * Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all\n   * pods in the namespace\n   */\n  selector?: { [key: string]: string };\n  /**\n   * The name of the service to expose\n   */\n  service?: string;\n  /**\n   * The service targetPort. This defaults to port and is only required if the service port is\n   * different from the target port (so the NetworkPolicy can be generated correctly).\n   */\n  targetPort?: number;\n}\n\n/**\n * Advanced HTTP settings for the route.\n */\nexport interface AdvancedHTTP {\n  /**\n   * Cross-Origin Resource Sharing policy (CORS).\n   */\n  corsPolicy?: CorsPolicy;\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  directResponse?: DirectResponse;\n  headers?: Headers;\n  /**\n   * Match the incoming request based on custom rules. Not permitted when using the\n   * passthrough gateway.\n   */\n  match?: AdvancedHTTPMatch[];\n  /**\n   * Retry policy for HTTP requests.\n   */\n  retries?: Retries;\n  /**\n   * Rewrite HTTP URIs and Authority headers.\n   */\n  rewrite?: Rewrite;\n  /**\n   * Timeout for HTTP requests, default is disabled.\n   */\n  timeout?: string;\n  /**\n   * Weight specifies the relative proportion of traffic to be forwarded to the destination.\n   */\n  weight?: number;\n}\n\n/**\n * Cross-Origin Resource Sharing policy (CORS).\n */\nexport interface CorsPolicy {\n  /**\n   * Indicates whether the caller is allowed to send the actual request (not the preflight)\n   * using credentials.\n   */\n  allowCredentials?: boolean;\n  /**\n   * List of HTTP headers that can be used when requesting the resource.\n   */\n  allowHeaders?: string[];\n  /**\n   * List of HTTP methods allowed to access the resource.\n   */\n  allowMethods?: string[];\n  allowOrigin?: string[];\n  /**\n   * String patterns that match allowed origins.\n   */\n  allowOrigins?: AllowOrigin[];\n  /**\n   * A list of HTTP headers that the browsers are allowed to access.\n   */\n  exposeHeaders?: string[];\n  /**\n   * Specifies how long the results of a preflight request can be cached.\n   */\n  maxAge?: string;\n}\n\nexport interface AllowOrigin {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n */\nexport interface DirectResponse {\n  /**\n   * Specifies the content of the response body.\n   */\n  body?: Body;\n  /**\n   * Specifies the HTTP response status to be returned.\n   */\n  status: number;\n}\n\n/**\n * Specifies the content of the response body.\n */\nexport interface Body {\n  /**\n   * response body as base64 encoded bytes.\n   */\n  bytes?: string;\n  string?: string;\n}\n\nexport interface Headers {\n  request?: Request;\n  response?: Response;\n}\n\nexport interface Request {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface Response {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface AdvancedHTTPMatch {\n  /**\n   * Flag to specify whether the URI matching should be case-insensitive.\n   */\n  ignoreUriCase?: boolean;\n  method?: PurpleMethod;\n  /**\n   * The name assigned to a match.\n   */\n  name: string;\n  /**\n   * Query parameters for matching.\n   */\n  queryParams?: { [key: string]: PurpleQueryParam };\n  uri?: PurpleURI;\n}\n\nexport interface PurpleMethod {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface PurpleQueryParam {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface PurpleURI {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * Retry policy for HTTP requests.\n */\nexport interface Retries {\n  /**\n   * Number of retries to be allowed for a given request.\n   */\n  attempts?: number;\n  /**\n   * Timeout per attempt for a given request, including the initial call and any retries.\n   */\n  perTryTimeout?: string;\n  /**\n   * Specifies the conditions under which retry takes place.\n   */\n  retryOn?: string;\n  /**\n   * Flag to specify whether the retries should retry to other localities.\n   */\n  retryRemoteLocalities?: boolean;\n}\n\n/**\n * Rewrite HTTP URIs and Authority headers.\n */\nexport interface Rewrite {\n  /**\n   * rewrite the Authority/Host header with this value.\n   */\n  authority?: string;\n  /**\n   * rewrite the path (or the prefix) portion of the URI with this value.\n   */\n  uri?: string;\n  /**\n   * rewrite the path portion of the URI with the specified regex.\n   */\n  uriRegexRewrite?: URIRegexRewrite;\n}\n\n/**\n * rewrite the path portion of the URI with the specified regex.\n */\nexport interface URIRegexRewrite {\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  match?: string;\n  /**\n   * The string that should replace into matching portions of original URI.\n   */\n  rewrite?: string;\n}\n\n/**\n * The name of the gateway to expose the service on (default: tenant)\n */\nexport enum Gateway {\n  Admin = \"admin\",\n  Passthrough = \"passthrough\",\n  Tenant = \"tenant\",\n}\n\nexport interface ExposeMatch {\n  /**\n   * Flag to specify whether the URI matching should be case-insensitive.\n   */\n  ignoreUriCase?: boolean;\n  method?: FluffyMethod;\n  /**\n   * The name assigned to a match.\n   */\n  name: string;\n  /**\n   * Query parameters for matching.\n   */\n  queryParams?: { [key: string]: FluffyQueryParam };\n  uri?: FluffyURI;\n}\n\nexport interface FluffyMethod {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface FluffyQueryParam {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface FluffyURI {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface Sso {\n  /**\n   * Always list this client in the Account UI, even if the user does not have an active\n   * session.\n   */\n  alwaysDisplayInConsole?: boolean;\n  /**\n   * The client authenticator type\n   */\n  clientAuthenticatorType?: ClientAuthenticatorType;\n  /**\n   * The client identifier registered with the identity provider.\n   */\n  clientId: string;\n  /**\n   * Default client scopes\n   */\n  defaultClientScopes?: string[];\n  /**\n   * A description for the client, can be a URL to an image to replace the login logo\n   */\n  description?: string;\n  /**\n   * Whether the SSO client is enabled\n   */\n  enabled?: boolean;\n  /**\n   * If true, the client will generate a new Auth Service client as well\n   */\n  isAuthSvcClient?: boolean;\n  /**\n   * Specifies display name of the client\n   */\n  name: string;\n  /**\n   * Valid URI pattern a browser can redirect to after a successful login. Simple wildcards\n   * are allowed such as 'https://unicorns.uds.dev/*'\n   */\n  redirectUris: string[];\n  /**\n   * Root URL appended to relative URLs\n   */\n  rootUrl?: string;\n  /**\n   * The client secret. Typically left blank and auto-generated.\n   */\n  secret?: string;\n  /**\n   * The name of the secret to store the client secret\n   */\n  secretName?: string;\n  /**\n   * A template for the generated secret\n   */\n  secretTemplate?: { [key: string]: string };\n  /**\n   * Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does\n   * not include the '*' wildcard though. To permit all origins, explicitly add '*'.\n   */\n  webOrigins?: string[];\n}\n\n/**\n * The client authenticator type\n */\nexport enum ClientAuthenticatorType {\n  ClientJwt = \"client-jwt\",\n  ClientSecret = \"client-secret\",\n}\n\nexport interface Status {\n  endpoints?: string[];\n  networkPolicyCount?: number;\n  observedGeneration?: number;\n  phase?: Phase;\n  ssoClients?: string[];\n}\n\nexport enum Phase {\n  Failed = \"Failed\",\n  Pending = \"Pending\",\n  Ready = \"Ready\",\n}\n\nRegisterKind(Package, {\n  group: \"uds.dev\",\n  version: \"v1alpha1\",\n  kind: \"Package\",\n});\n", "// This file is auto-generated by kubernetes-fluent-client, do not edit manually\n\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n\nexport class Exemption extends GenericKind {\n  spec?: Spec;\n  status?: Status;\n}\n\nexport interface Spec {\n  /**\n   * Policy exemptions\n   */\n  exemptions?: ExemptionElement[];\n}\n\nexport interface ExemptionElement {\n  /**\n   * Reasons as to why this exemption is needed\n   */\n  description?: string;\n  /**\n   * Resource to exempt (Regex allowed for name)\n   */\n  matcher: Matcher;\n  /**\n   * A list of policies to override\n   */\n  policies: Policy[];\n  /**\n   * title to give the exemption for reporting purposes\n   */\n  title?: string;\n}\n\n/**\n * Resource to exempt (Regex allowed for name)\n */\nexport interface Matcher {\n  kind?: Kind;\n  name: string;\n  namespace: string;\n}\n\nexport enum Kind {\n  Pod = \"pod\",\n  Service = \"service\",\n}\n\nexport enum Policy {\n  DisallowHostNamespaces = \"DisallowHostNamespaces\",\n  DisallowNodePortServices = \"DisallowNodePortServices\",\n  DisallowPrivileged = \"DisallowPrivileged\",\n  DisallowSELinuxOptions = \"DisallowSELinuxOptions\",\n  DropAllCapabilities = \"DropAllCapabilities\",\n  RequireNonRootUser = \"RequireNonRootUser\",\n  RestrictCapabilities = \"RestrictCapabilities\",\n  RestrictExternalNames = \"RestrictExternalNames\",\n  RestrictHostPathWrite = \"RestrictHostPathWrite\",\n  RestrictHostPorts = \"RestrictHostPorts\",\n  RestrictProcMount = \"RestrictProcMount\",\n  RestrictSELinuxType = \"RestrictSELinuxType\",\n  RestrictSeccomp = \"RestrictSeccomp\",\n  RestrictVolumeTypes = \"RestrictVolumeTypes\",\n}\n\nexport interface Status {\n  observedGeneration?: number;\n  phase?: Phase;\n  titles?: string[];\n}\n\nexport enum Phase {\n  Failed = \"Failed\",\n  Pending = \"Pending\",\n  Ready = \"Ready\",\n}\n\nRegisterKind(Exemption, {\n  group: \"uds.dev\",\n  version: \"v1alpha1\",\n  kind: \"Exemption\",\n});\n", "// This file is auto-generated by kubernetes-fluent-client, do not edit manually\n\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n\nexport class VirtualService extends GenericKind {\n  /**\n   * Configuration affecting label/content routing, sni routing, etc. See more details at:\n   * https://istio.io/docs/reference/config/networking/virtual-service.html\n   */\n  spec?: Spec;\n  status?: { [key: string]: unknown };\n}\n\n/**\n * Configuration affecting label/content routing, sni routing, etc. See more details at:\n * https://istio.io/docs/reference/config/networking/virtual-service.html\n */\nexport interface Spec {\n  /**\n   * A list of namespaces to which this virtual service is exported.\n   */\n  exportTo?: string[];\n  /**\n   * The names of gateways and sidecars that should apply these routes.\n   */\n  gateways?: string[];\n  /**\n   * The destination hosts to which traffic is being sent.\n   */\n  hosts?: string[];\n  /**\n   * An ordered list of route rules for HTTP traffic.\n   */\n  http?: HTTP[];\n  /**\n   * An ordered list of route rules for opaque TCP traffic.\n   */\n  tcp?: TCP[];\n  /**\n   * An ordered list of route rule for non-terminated TLS & HTTPS traffic.\n   */\n  tls?: Tl[];\n}\n\nexport interface HTTP {\n  /**\n   * Cross-Origin Resource Sharing policy (CORS).\n   */\n  corsPolicy?: CorsPolicy;\n  /**\n   * Delegate is used to specify the particular VirtualService which can be used to define\n   * delegate HTTPRoute.\n   */\n  delegate?: Delegate;\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  directResponse?: DirectResponse;\n  /**\n   * Fault injection policy to apply on HTTP traffic at the client side.\n   */\n  fault?: Fault;\n  headers?: HTTPHeaders;\n  /**\n   * Match conditions to be satisfied for the rule to be activated.\n   */\n  match?: HTTPMatch[];\n  /**\n   * Mirror HTTP traffic to a another destination in addition to forwarding the requests to\n   * the intended destination.\n   */\n  mirror?: PurpleMirror;\n  mirror_percent?: number;\n  mirrorPercent?: number;\n  /**\n   * Percentage of the traffic to be mirrored by the `mirror` field.\n   */\n  mirrorPercentage?: MirrorPercentageObject;\n  /**\n   * Specifies the destinations to mirror HTTP traffic in addition to the original destination.\n   */\n  mirrors?: MirrorElement[];\n  /**\n   * The name assigned to the route for debugging purposes.\n   */\n  name?: string;\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  redirect?: Redirect;\n  /**\n   * Retry policy for HTTP requests.\n   */\n  retries?: Retries;\n  /**\n   * Rewrite HTTP URIs and Authority headers.\n   */\n  rewrite?: Rewrite;\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  route?: HTTPRoute[];\n  /**\n   * Timeout for HTTP requests, default is disabled.\n   */\n  timeout?: string;\n}\n\n/**\n * Cross-Origin Resource Sharing policy (CORS).\n */\nexport interface CorsPolicy {\n  /**\n   * Indicates whether the caller is allowed to send the actual request (not the preflight)\n   * using credentials.\n   */\n  allowCredentials?: boolean;\n  /**\n   * List of HTTP headers that can be used when requesting the resource.\n   */\n  allowHeaders?: string[];\n  /**\n   * List of HTTP methods allowed to access the resource.\n   */\n  allowMethods?: string[];\n  allowOrigin?: string[];\n  /**\n   * String patterns that match allowed origins.\n   */\n  allowOrigins?: AllowOrigin[];\n  /**\n   * A list of HTTP headers that the browsers are allowed to access.\n   */\n  exposeHeaders?: string[];\n  /**\n   * Specifies how long the results of a preflight request can be cached.\n   */\n  maxAge?: string;\n}\n\nexport interface AllowOrigin {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * Delegate is used to specify the particular VirtualService which can be used to define\n * delegate HTTPRoute.\n */\nexport interface Delegate {\n  /**\n   * Name specifies the name of the delegate VirtualService.\n   */\n  name?: string;\n  /**\n   * Namespace specifies the namespace where the delegate VirtualService resides.\n   */\n  namespace?: string;\n}\n\n/**\n * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n */\nexport interface DirectResponse {\n  /**\n   * Specifies the content of the response body.\n   */\n  body?: Body;\n  /**\n   * Specifies the HTTP response status to be returned.\n   */\n  status?: number;\n}\n\n/**\n * Specifies the content of the response body.\n */\nexport interface Body {\n  /**\n   * response body as base64 encoded bytes.\n   */\n  bytes?: string;\n  string?: string;\n}\n\n/**\n * Fault injection policy to apply on HTTP traffic at the client side.\n */\nexport interface Fault {\n  /**\n   * Abort Http request attempts and return error codes back to downstream service, giving the\n   * impression that the upstream service is faulty.\n   */\n  abort?: Abort;\n  /**\n   * Delay requests before forwarding, emulating various failures such as network issues,\n   * overloaded upstream service, etc.\n   */\n  delay?: Delay;\n}\n\n/**\n * Abort Http request attempts and return error codes back to downstream service, giving the\n * impression that the upstream service is faulty.\n */\nexport interface Abort {\n  /**\n   * GRPC status code to use to abort the request.\n   */\n  grpcStatus?: string;\n  http2Error?: string;\n  /**\n   * HTTP status code to use to abort the Http request.\n   */\n  httpStatus?: number;\n  /**\n   * Percentage of requests to be aborted with the error code provided.\n   */\n  percentage?: AbortPercentage;\n}\n\n/**\n * Percentage of requests to be aborted with the error code provided.\n */\nexport interface AbortPercentage {\n  value?: number;\n}\n\n/**\n * Delay requests before forwarding, emulating various failures such as network issues,\n * overloaded upstream service, etc.\n */\nexport interface Delay {\n  exponentialDelay?: string;\n  /**\n   * Add a fixed delay before forwarding the request.\n   */\n  fixedDelay?: string;\n  /**\n   * Percentage of requests on which the delay will be injected (0-100).\n   */\n  percent?: number;\n  /**\n   * Percentage of requests on which the delay will be injected.\n   */\n  percentage?: DelayPercentage;\n}\n\n/**\n * Percentage of requests on which the delay will be injected.\n */\nexport interface DelayPercentage {\n  value?: number;\n}\n\nexport interface HTTPHeaders {\n  request?: PurpleRequest;\n  response?: PurpleResponse;\n}\n\nexport interface PurpleRequest {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface PurpleResponse {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface HTTPMatch {\n  /**\n   * HTTP Authority values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n   * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n   * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  authority?: Authority;\n  /**\n   * Names of gateways where the rule should be applied.\n   */\n  gateways?: string[];\n  /**\n   * The header keys must be lowercase and use hyphen as the separator, e.g.\n   */\n  headers?: { [key: string]: Header };\n  /**\n   * Flag to specify whether the URI matching should be case-insensitive.\n   */\n  ignoreUriCase?: boolean;\n  /**\n   * HTTP Method values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n   * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n   * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  method?: Method;\n  /**\n   * The name assigned to a match.\n   */\n  name?: string;\n  /**\n   * Specifies the ports on the host that is being addressed.\n   */\n  port?: number;\n  /**\n   * Query parameters for matching.\n   */\n  queryParams?: { [key: string]: QueryParam };\n  /**\n   * URI Scheme values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n   * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n   * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  scheme?: Scheme;\n  /**\n   * One or more labels that constrain the applicability of a rule to source (client)\n   * workloads with the given labels.\n   */\n  sourceLabels?: { [key: string]: string };\n  /**\n   * Source namespace constraining the applicability of a rule to workloads in that namespace.\n   */\n  sourceNamespace?: string;\n  /**\n   * The human readable prefix to use when emitting statistics for this route.\n   */\n  statPrefix?: string;\n  /**\n   * URI to match values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n   * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n   * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  uri?: URI;\n  /**\n   * withoutHeader has the same syntax with the header, but has opposite meaning.\n   */\n  withoutHeaders?: { [key: string]: WithoutHeader };\n}\n\n/**\n * HTTP Authority values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n */\nexport interface Authority {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface Header {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * HTTP Method values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n */\nexport interface Method {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface QueryParam {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * URI Scheme values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n */\nexport interface Scheme {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * URI to match values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n */\nexport interface URI {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface WithoutHeader {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * Mirror HTTP traffic to a another destination in addition to forwarding the requests to\n * the intended destination.\n */\nexport interface PurpleMirror {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: MirrorPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface MirrorPort {\n  number?: number;\n}\n\n/**\n * Percentage of the traffic to be mirrored by the `mirror` field.\n */\nexport interface MirrorPercentageObject {\n  value?: number;\n}\n\nexport interface MirrorElement {\n  /**\n   * Destination specifies the target of the mirror operation.\n   */\n  destination?: MirrorDestination;\n  /**\n   * Percentage of the traffic to be mirrored by the `destination` field.\n   */\n  percentage?: MirrorPercentage;\n}\n\n/**\n * Destination specifies the target of the mirror operation.\n */\nexport interface MirrorDestination {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: PurplePort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface PurplePort {\n  number?: number;\n}\n\n/**\n * Percentage of the traffic to be mirrored by the `destination` field.\n */\nexport interface MirrorPercentage {\n  value?: number;\n}\n\n/**\n * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n */\nexport interface Redirect {\n  /**\n   * On a redirect, overwrite the Authority/Host portion of the URL with this value.\n   */\n  authority?: string;\n  /**\n   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80\n   * for HTTP and 443 for HTTPS.\n   */\n  derivePort?: DerivePort;\n  /**\n   * On a redirect, overwrite the port portion of the URL with this value.\n   */\n  port?: number;\n  /**\n   * On a redirect, Specifies the HTTP status code to use in the redirect response.\n   */\n  redirectCode?: number;\n  /**\n   * On a redirect, overwrite the scheme portion of the URL with this value.\n   */\n  scheme?: string;\n  /**\n   * On a redirect, overwrite the Path portion of the URL with this value.\n   */\n  uri?: string;\n}\n\n/**\n * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80\n * for HTTP and 443 for HTTPS.\n */\nexport enum DerivePort {\n  FromProtocolDefault = \"FROM_PROTOCOL_DEFAULT\",\n  FromRequestPort = \"FROM_REQUEST_PORT\",\n}\n\n/**\n * Retry policy for HTTP requests.\n */\nexport interface Retries {\n  /**\n   * Number of retries to be allowed for a given request.\n   */\n  attempts?: number;\n  /**\n   * Timeout per attempt for a given request, including the initial call and any retries.\n   */\n  perTryTimeout?: string;\n  /**\n   * Specifies the conditions under which retry takes place.\n   */\n  retryOn?: string;\n  /**\n   * Flag to specify whether the retries should retry to other localities.\n   */\n  retryRemoteLocalities?: boolean;\n}\n\n/**\n * Rewrite HTTP URIs and Authority headers.\n */\nexport interface Rewrite {\n  /**\n   * rewrite the Authority/Host header with this value.\n   */\n  authority?: string;\n  /**\n   * rewrite the path (or the prefix) portion of the URI with this value.\n   */\n  uri?: string;\n  /**\n   * rewrite the path portion of the URI with the specified regex.\n   */\n  uriRegexRewrite?: URIRegexRewrite;\n}\n\n/**\n * rewrite the path portion of the URI with the specified regex.\n */\nexport interface URIRegexRewrite {\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  match?: string;\n  /**\n   * The string that should replace into matching portions of original URI.\n   */\n  rewrite?: string;\n}\n\nexport interface HTTPRoute {\n  /**\n   * Destination uniquely identifies the instances of a service to which the\n   * request/connection should be forwarded to.\n   */\n  destination?: PurpleDestination;\n  headers?: RouteHeaders;\n  /**\n   * Weight specifies the relative proportion of traffic to be forwarded to the destination.\n   */\n  weight?: number;\n}\n\n/**\n * Destination uniquely identifies the instances of a service to which the\n * request/connection should be forwarded to.\n */\nexport interface PurpleDestination {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: FluffyPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface FluffyPort {\n  number?: number;\n}\n\nexport interface RouteHeaders {\n  request?: FluffyRequest;\n  response?: FluffyResponse;\n}\n\nexport interface FluffyRequest {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface FluffyResponse {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface TCP {\n  /**\n   * Match conditions to be satisfied for the rule to be activated.\n   */\n  match?: TCPMatch[];\n  /**\n   * The destination to which the connection should be forwarded to.\n   */\n  route?: TCPRoute[];\n}\n\nexport interface TCPMatch {\n  /**\n   * IPv4 or IPv6 ip addresses of destination with optional subnet.\n   */\n  destinationSubnets?: string[];\n  /**\n   * Names of gateways where the rule should be applied.\n   */\n  gateways?: string[];\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: number;\n  /**\n   * One or more labels that constrain the applicability of a rule to workloads with the given\n   * labels.\n   */\n  sourceLabels?: { [key: string]: string };\n  /**\n   * Source namespace constraining the applicability of a rule to workloads in that namespace.\n   */\n  sourceNamespace?: string;\n  sourceSubnet?: string;\n}\n\nexport interface TCPRoute {\n  /**\n   * Destination uniquely identifies the instances of a service to which the\n   * request/connection should be forwarded to.\n   */\n  destination?: FluffyDestination;\n  /**\n   * Weight specifies the relative proportion of traffic to be forwarded to the destination.\n   */\n  weight?: number;\n}\n\n/**\n * Destination uniquely identifies the instances of a service to which the\n * request/connection should be forwarded to.\n */\nexport interface FluffyDestination {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: TentacledPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface TentacledPort {\n  number?: number;\n}\n\nexport interface Tl {\n  /**\n   * Match conditions to be satisfied for the rule to be activated.\n   */\n  match?: TlMatch[];\n  /**\n   * The destination to which the connection should be forwarded to.\n   */\n  route?: TlRoute[];\n}\n\nexport interface TlMatch {\n  /**\n   * IPv4 or IPv6 ip addresses of destination with optional subnet.\n   */\n  destinationSubnets?: string[];\n  /**\n   * Names of gateways where the rule should be applied.\n   */\n  gateways?: string[];\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: number;\n  /**\n   * SNI (server name indicator) to match on.\n   */\n  sniHosts?: string[];\n  /**\n   * One or more labels that constrain the applicability of a rule to workloads with the given\n   * labels.\n   */\n  sourceLabels?: { [key: string]: string };\n  /**\n   * Source namespace constraining the applicability of a rule to workloads in that namespace.\n   */\n  sourceNamespace?: string;\n}\n\nexport interface TlRoute {\n  /**\n   * Destination uniquely identifies the instances of a service to which the\n   * request/connection should be forwarded to.\n   */\n  destination?: TentacledDestination;\n  /**\n   * Weight specifies the relative proportion of traffic to be forwarded to the destination.\n   */\n  weight?: number;\n}\n\n/**\n * Destination uniquely identifies the instances of a service to which the\n * request/connection should be forwarded to.\n */\nexport interface TentacledDestination {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: StickyPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface StickyPort {\n  number?: number;\n}\n\nRegisterKind(VirtualService, {\n  group: \"networking.istio.io\",\n  version: \"v1beta1\",\n  kind: \"VirtualService\",\n});\n", "import { KubernetesObject, V1Container, V1SecurityContext } from \"@kubernetes/client-node\";\nimport { Capability, PeprMutateRequest, PeprValidateRequest, a } from \"pepr\";\nimport { Policy } from \"../operator/crd\";\n\nexport type Ctx = {\n  name?: string;\n  ctx: V1SecurityContext;\n};\n\nexport const policies = new Capability({\n  name: \"uds-core-policies\",\n  description:\n    \"Collection of core validation policies for Pods, ConfigMaps, and other Kubernetes resources.\",\n});\n\nexport const { Store, When } = policies;\n\n// Returns all volumes in the pod\nexport function volumes(request: PeprValidateRequest<a.Pod>) {\n  return request.Raw.spec?.volumes || [];\n}\n\n// Returns all containers in the pod\nexport function containers(request: PeprValidateRequest<a.Pod> | PeprMutateRequest<a.Pod>) {\n  return [\n    ...(request.Raw.spec?.containers || []),\n    ...(request.Raw.spec?.initContainers || []),\n    ...(request.Raw.spec?.ephemeralContainers || []),\n  ];\n}\n\n/**\n * Returns all containers in the pod that have a securityContext\n *\n * @param request\n * @returns Map of container name to securityContext\n */\nexport function securityContextContainers(request: PeprValidateRequest<a.Pod>) {\n  return containers(request)\n    .filter(c => c.securityContext)\n    .filter(c => !isIstioInitContainer(request, c))\n    .map(c => ({ name: c.name, ctx: c.securityContext! }) as Ctx);\n}\n\nexport function securityContextMessage(\n  msg: string,\n  authorized: (string | undefined)[],\n  ctx: Ctx[],\n) {\n  const violations = ctx.map(c => JSON.stringify(c)).join(\" | \");\n  const authMsg = authorized.filter(a => a).join(\" | \");\n\n  return `${msg}. Authorized: [${authMsg}] Found: ${violations}`;\n}\n\n/**\n * Returns true if the container looks like an istio init container\n *\n * @param request the request to check\n * @param container the container to check\n * @returns\n */\nexport function isIstioInitContainer(\n  request: PeprValidateRequest<a.Pod> | PeprMutateRequest<a.Pod>,\n  container?: V1Container,\n) {\n  // Check for the sidecar.istio.io/status annotation\n  const hasAnnotation = request.HasAnnotation(\"sidecar.istio.io/status\");\n  if (!hasAnnotation) {\n    return false;\n  }\n\n  // Check for what looks like an istio sidecar\n  const possibleSidecar = request.Raw.spec?.containers?.find(\n    c =>\n      c.name === \"istio-proxy\" &&\n      c.ports?.find(p => p.name === \"http-envoy-prom\") &&\n      c.args?.includes(\"proxy\"),\n  );\n  if (!possibleSidecar) {\n    return false;\n  }\n\n  // Check for what looks like an istio init container\n  const possibleInitContainer =\n    container?.name === \"istio-init\" && container.args?.includes(\"istio-iptables\");\n  if (!possibleInitContainer) {\n    return false;\n  }\n\n  // If we get here, it's an istio init container\n  return true;\n}\n\nfunction transform(policy: Policy) {\n  return policy\n    .split(/(?=[A-Z])/)\n    .join(\"-\")\n    .toLowerCase();\n}\n\nexport function annotateMutation<T extends KubernetesObject>(\n  request: PeprMutateRequest<T>,\n  policy: Policy,\n) {\n  request.SetAnnotation(`uds-core.pepr.dev/mutated`, transform(policy));\n}\n", "import { KubernetesObject } from \"kubernetes-fluent-client\";\nimport { Log, PeprMutateRequest, PeprValidateRequest } from \"pepr\";\nimport { Policy } from \"../../operator/crd\";\nimport { Store } from \"../common\";\n\n/**\n * Check a resource against an exemption list for use by the validation action.\n *\n * @param policy Policy to get exemptions for\n * @param request The request to check.\n * @returns True if exempt and false otherwise\n */\nexport function isExempt<T extends KubernetesObject>(\n  request: PeprValidateRequest<T> | PeprMutateRequest<T>,\n  policy: Policy,\n) {\n  const exemptList = JSON.parse(Store.getItem(policy) || \"[]\");\n\n  // Loop through the exempt list\n  for (const exempt of exemptList) {\n    // If the exempt namespace is specified, check it\n    if (exempt.namespace && exempt.namespace !== request.Raw.metadata?.namespace) {\n      continue;\n    }\n\n    // If the exempt name is specified, check it\n    const name = request.Raw.metadata?.name || request.Raw.metadata?.generateName;\n    if (exempt.name && !name?.match(exempt.name)) {\n      continue;\n    }\n\n    // If we get here, the request is exempt\n    Log.info(\"request is exempt\", { exempt });\n    return true;\n  }\n\n  // No exemptions matched\n  return false;\n}\n\n/**\n *\n * @param policy\n * @returns Function that takes PeprMutateRequest and evaluates if request isExempt()\n */\nexport function markExemption<T extends KubernetesObject>(policy: Policy) {\n  return (request: PeprMutateRequest<T>) => {\n    if (isExempt(request, policy)) {\n      request.SetAnnotation(`uds-core.pepr.dev/uds-core-policies.${policy}`, \"exempted\");\n      return;\n    }\n  };\n}\n", "import { a } from \"pepr\";\n\nimport { When, containers, volumes } from \"./common\";\nimport { Policy } from \"../operator/crd\";\nimport { isExempt, markExemption } from \"./exemptions\";\n\n/**\n * Restrict Volume Types for Pods\n *\n * Volume types, beyond the core set, should be restricted to limit exposure to potential vulnerabilities\n * in Container Storage Interface (CSI) drivers.  In addition, HostPath volumes should not be allowed\n * because host directories could be exploited to access shared data or escalate privileges.  This policy\n * restricts use of volume types to the allowed list.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-volume-types.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictVolumeTypes))\n  .Validate(request => {\n    // List of allowed volume types\n    const allowedVolumeTypes = [\n      \"configMap\",\n      \"csi\",\n      \"downwardAPI\",\n      \"emptyDir\",\n      \"ephemeral\",\n      \"persistentVolumeClaim\",\n      \"projected\",\n      \"secret\",\n    ];\n\n    if (isExempt(request, Policy.RestrictVolumeTypes)) {\n      return request.Approve();\n    }\n\n    // Check all volumes in the pod spec, if any\n    for (const volume of volumes(request)) {\n      // Get the volume type, which will be the only key in the volume object other than \"name\"\n      const volumeType = Object.keys(volume).find(key => key !== \"name\") || \"unknown\";\n\n      // If the volume type is not in the allowed list, deny the request\n      if (!allowedVolumeTypes.includes(volumeType)) {\n        return request.Deny(\n          `Volume ${volume.name} has a disallowed volume type of '${volumeType}'.`,\n        );\n      }\n    }\n\n    // All volumes are allowed, so approve the request\n    return request.Approve();\n  });\n\n/**\n * Restrict hostPath Volume Writable Paths for Pods\n *\n * hostPath volumes consume the underlying node's file system. If hostPath volumes are not universally disabled,\n * they should be required to be read-only. Pods which are allowed to mount hostPath volumes in read/write mode\n * pose a security risk even if confined to a \"safe\" file system on the host and may escape those confines\n * (see https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts). This policy checks containers for\n * hostPath volumes and validates they are explicitly mounted in readOnly mode.  It is strongly recommended to\n * pair this policy with another to restrict the path of hostPath volumes to a known list.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-host-path-write.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictHostPathWrite))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictHostPathWrite)) {\n      return request.Approve();\n    }\n\n    for (const volume of volumes(request)) {\n      // If the volume is a hostPath\n      if (volume.hostPath) {\n        // Check all mounts in any container for this volume and verify they are readOnly\n        const hasRWMount = containers(request)\n          .flatMap(c => c.volumeMounts || [])\n          .filter(mount => mount.name === volume.name)\n          .find(mount => !mount.readOnly);\n\n        // If any mount is not readOnly, deny the request\n        if (hasRWMount) {\n          return request.Deny(`hostPath volume '${volume.name}' must be mounted as readOnly.`);\n        }\n      }\n    }\n\n    // All volumes are allowed, so approve the request\n    return request.Approve();\n  });\n", "import { a } from \"pepr\";\n\nimport { When, containers } from \"./common\";\nimport { Policy } from \"../operator/crd\";\nimport { isExempt, markExemption } from \"./exemptions\";\n\n/**\n * This policy prevents pods from sharing the host namespaces.\n *\n * Host namespaces (Process ID namespace, Inter-Process Communication namespace, and network namespace)\n * allow access to shared information and can be used to elevate privileges. Pods should not be allowed\n * access to host namespaces. This policy ensures fields which make use of these host namespaces are\n * set to `false`.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-host-namespaces.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.DisallowHostNamespaces))\n  .Validate(request => {\n    if (isExempt(request, Policy.DisallowHostNamespaces)) {\n      return request.Approve();\n    }\n\n    const pod = request.Raw.spec!;\n\n    // If the pod is using the host network, IPC, or PID namespaces, deny the request.\n    if (pod.hostNetwork || pod.hostIPC || pod.hostPID) {\n      return request.Deny(\n        \"Sharing the host namespaces is disallowed. The fields spec.hostNetwork, spec.hostIPC, and spec.hostPID must not be set to true.\",\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * This policy restricts the use of host ports in Pods.\n *\n * Access to host ports can allow potential snooping of network traffic and should be\n * restricted to a known list. This policy ensures only approved ports\n * are defined in container's `hostPort` field.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-host-ports.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictHostPorts))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictHostPorts)) {\n      return request.Approve();\n    }\n\n    // Check all containers in the pod spec, and find the first one that has a host port, if any\n    const hasHostPort = containers(request)\n      .flatMap(c => c.ports || [])\n      .find(p => p.hostPort);\n\n    // If the container has a host port, deny the request\n    if (hasHostPort) {\n      return request.Deny(`Host ports are not allowed.`);\n    }\n\n    return request.Approve();\n  });\n\n/**\n * This policy restricts the use of external names in services to mitigate the risk of MITM attacks.\n *\n * Service external names can be exploited by attackers to redirect traffic to malicious locations.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-external-names.yaml\n */\nWhen(a.Service)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictExternalNames))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictExternalNames)) {\n      return request.Approve();\n    }\n    if (request.Raw.spec?.type === \"ExternalName\") {\n      return request.Deny(\"ExternalName services are not allowed.\");\n    }\n\n    return request.Approve();\n  });\n\n/**\n * This policy prevents the use of NodePort services in Kubernetes.\n *\n * NodePort services can pose security risks as they use a host port to receive traffic,\n * which cannot be controlled by a NetworkPolicy. This policy ensures that Services\n * do not use the NodePort type for enhanced security.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-nodeport-services.yaml\n */\nWhen(a.Service)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.DisallowNodePortServices))\n  .Validate(request => {\n    if (isExempt(request, Policy.DisallowNodePortServices)) {\n      return request.Approve();\n    }\n    // If the service is of type NodePort, deny the request.\n    if (request.Raw.spec?.type === \"NodePort\") {\n      return request.Deny(\"NodePort services are not allowed.\");\n    }\n\n    return request.Approve();\n  });\n", "import { K8s, Log, kind } from \"pepr\";\n\nimport { UDSPackage } from \"../../crd\";\n\nconst injectionLabel = \"istio-injection\";\nconst injectionAnnotation = \"uds.dev/original-istio-injection\";\n\n/**\n * Syncs the package namespace istio-injection label and adds a label for the package name\n *\n * @param pkg\n */\nexport async function enableInjection(pkg: UDSPackage) {\n  if (!pkg.metadata?.namespace || !pkg.metadata.name) {\n    throw new Error(`Invalid Package definition, missing namespace or name`);\n  }\n\n  const sourceNS = await K8s(kind.Namespace).Get(pkg.metadata.namespace);\n  const labels = sourceNS.metadata?.labels || {};\n  const annotations = sourceNS.metadata?.annotations || {};\n  const pkgKey = `uds.dev/pkg-${pkg.metadata.name}`;\n\n  // Save the original value of the istio-injection label only if it's not already set\n  if (!annotations[injectionLabel]) {\n    annotations[injectionAnnotation] = labels[injectionLabel] || \"non-existent\";\n  }\n\n  // Ensure the namespace is configured\n  if (!annotations[pkgKey] || labels[injectionLabel] !== \"enabled\") {\n    // Ensure Istio injection is enabled\n    labels[injectionLabel] = \"enabled\";\n\n    // Add the package annotation\n    annotations[pkgKey] = \"true\";\n\n    // Apply the updated Namespace\n    await K8s(kind.Namespace).Apply(\n      {\n        metadata: {\n          name: pkg.metadata.namespace,\n          labels,\n          annotations,\n        },\n      },\n      { force: true },\n    );\n\n    await killPods(pkg.metadata.namespace, true);\n  }\n}\n\n/**\n * Restores the namespace\n *\n * @param pkg the package to cleanup\n */\nexport async function cleanupNamespace(pkg: UDSPackage) {\n  if (!pkg.metadata?.namespace || !pkg.metadata.name) {\n    throw new Error(`Invalid Package definition, missing namespace or name`);\n  }\n\n  const sourceNS = await K8s(kind.Namespace).Get(pkg.metadata.namespace);\n  const labels = sourceNS.metadata?.labels || {};\n  const annotations = sourceNS.metadata?.annotations || {};\n\n  // Remove the package annotation\n  delete annotations[`uds.dev/pkg-${pkg.metadata.name}`];\n\n  // If there are no more UDS Package annotations, restore the original value of the istio-injection label\n  if (!Object.keys(annotations).find(key => key.startsWith(\"uds.dev/pkg-\"))) {\n    labels[injectionLabel] = annotations[injectionAnnotation];\n    // If the original value was non-existent, remove the label\n    if (labels[injectionLabel] === \"non-existent\") {\n      delete labels[injectionLabel];\n    }\n    delete annotations[injectionAnnotation];\n  }\n\n  // Apply the updated Namespace\n  await K8s(kind.Namespace).Apply(\n    {\n      metadata: {\n        name: pkg.metadata.namespace,\n        labels,\n        annotations,\n      },\n    },\n    { force: true },\n  );\n\n  await killPods(pkg.metadata.namespace, false);\n}\n\n/**\n * Forces deletion of pods with the incorrect istio sidecar state\n *\n * @param ns\n * @param enableInjection\n */\nasync function killPods(ns: string, enableInjection: boolean) {\n  // Get all pods in the namespace\n  const pods = await K8s(kind.Pod).InNamespace(ns).Get();\n  const groups: Record<string, kind.Pod[]> = {};\n\n  // Group the pods by owner UID\n  for (const pod of pods.items) {\n    // Ignore pods that already have a deletion timestamp\n    if (pod.metadata?.deletionTimestamp) {\n      continue;\n    }\n\n    const foundSidecar = pod.spec?.containers?.find(c => c.name === \"istio-proxy\");\n\n    // If enabling injection, ignore pods that already have the istio sidecar\n    if (enableInjection && foundSidecar) {\n      continue;\n    }\n\n    // If disabling injection, ignore pods that don't have the istio sidecar\n    if (!enableInjection && !foundSidecar) {\n      continue;\n    }\n\n    // Get the UID of the owner of the pod or default to \"other\" (shouldn't happen)\n    const controlledBy = pod.metadata?.ownerReferences?.find(ref => ref.controller)?.uid || \"other\";\n    groups[controlledBy] = groups[controlledBy] || [];\n    groups[controlledBy].push(pod);\n  }\n\n  // Delete each group of pods\n  for (const group of Object.values(groups)) {\n    // If this is a daemonset, delete the pods in reverse name order\n    if (group[0].metadata?.ownerReferences?.find(ref => ref.kind === \"DaemonSet\")) {\n      group.sort((a, b) => (b.metadata?.name || \"\").localeCompare(a.metadata?.name || \"\"));\n    }\n\n    for (const pod of group) {\n      Log.info(`Deleting pod ${ns}/${pod.metadata?.name} to enable the istio sidecar`);\n      await K8s(kind.Pod).Delete(pod);\n    }\n  }\n}\n", "import { K8s, Log, fetch, kind } from \"pepr\";\n\nimport { UDSConfig } from \"../../../config\";\nimport { Store } from \"../../common\";\nimport { Sso, UDSPackage } from \"../../crd\";\nimport { getOwnerRef } from \"../utils\";\nimport { Client } from \"./types\";\n\nconst apiURL =\n  \"http://keycloak-http.keycloak.svc.cluster.local:8080/realms/uds/clients-registrations/default\";\n\n// Template regex to match clientField() references, see https://regex101.com/r/e41Dsk/3 for details\nconst secretTemplateRegex = new RegExp(\n  'clientField\\\\(([a-zA-Z]+)\\\\)(?:\\\\[\"?([\\\\w]+)\"?\\\\]|(\\\\.json\\\\(\\\\)))?',\n  \"gm\",\n);\n\n/**\n * Create or update the Keycloak clients for the package\n *\n * @param pkg the package to process\n *\n * @returns the list of client refs\n */\nexport async function keycloak(pkg: UDSPackage) {\n  // Get the list of clients from the package\n  const clientReqs = pkg.spec?.sso || [];\n  const refs: string[] = [];\n\n  // Pull the isAuthSvcClient prop as it's not part of the KC client spec\n  for (const clientReq of clientReqs) {\n    const ref = await syncClient(clientReq, pkg);\n    refs.push(ref);\n  }\n\n  await purgeSSOClients(pkg, refs);\n\n  return refs;\n}\n\n/**\n * Remove any remaining clients that are not in the refs list\n *\n * @param pkg the package to process\n * @param refs the list of client refs to keep\n */\nexport async function purgeSSOClients(pkg: UDSPackage, refs: string[] = []) {\n  // Check for any clients that are no longer in the package and remove them\n  const currentClients = pkg.status?.ssoClients || [];\n  const toRemove = currentClients.filter(client => !refs.includes(client));\n  for (const ref of toRemove) {\n    const token = Store.getItem(ref);\n    const clientId = ref.replace(\"sso-client-\", \"\");\n    if (token) {\n      Store.removeItem(ref);\n      await apiCall({ clientId }, \"DELETE\", token);\n    } else {\n      Log.warn(pkg.metadata, `Failed to remove client ${clientId}, token not found`);\n    }\n  }\n}\n\nasync function syncClient(\n  { isAuthSvcClient, secretName, secretTemplate, ...clientReq }: Sso,\n  pkg: UDSPackage,\n  isRetry = false,\n) {\n  Log.debug(pkg.metadata, `Processing client request: ${clientReq.clientId}`);\n\n  try {\n    // Not including the CR data in the ref because Keycloak client IDs must be unique already\n    const name = `sso-client-${clientReq.clientId}`;\n    const token = Store.getItem(name);\n\n    let client: Client;\n\n    // If an existing client is found, update it\n    if (token && !isRetry) {\n      Log.debug(pkg.metadata, `Found existing token for ${clientReq.clientId}`);\n      client = await apiCall(clientReq, \"PUT\", token);\n    } else {\n      Log.debug(pkg.metadata, `Creating new client for ${clientReq.clientId}`);\n      client = await apiCall(clientReq);\n    }\n\n    // Write the new token to the store\n    await Store.setItemAndWait(name, client.registrationAccessToken!);\n\n    // Remove the registrationAccessToken from the client object to avoid problems (one-time use token)\n    delete client.registrationAccessToken;\n\n    // Create or update the client secret\n    await K8s(kind.Secret).Apply({\n      metadata: {\n        namespace: pkg.metadata!.namespace,\n        // Use the CR secret name if provided, otherwise use the client name\n        name: secretName || name,\n        labels: {\n          \"uds/package\": pkg.metadata!.name,\n        },\n        // Use the CR as the owner ref for each VirtualService\n        ownerReferences: getOwnerRef(pkg),\n      },\n      data: generateSecretData(client, secretTemplate),\n    });\n\n    if (isAuthSvcClient) {\n      // Do things here\n    }\n\n    return name;\n  } catch (err) {\n    const msg =\n      `Failed to process client request '${clientReq.clientId}' for ` +\n      `${pkg.metadata?.namespace}/${pkg.metadata?.name}. This can occur if a client already exists with the same ID that Pepr isn't tracking.`;\n    Log.error({ err }, msg);\n\n    if (isRetry) {\n      Log.error(`${msg}, retry failed, aborting`);\n      throw new Error(`${msg}. RETRY FAILED, aborting: ${JSON.stringify(err)}`);\n    }\n\n    // Retry the request\n    Log.warn(`${msg}, retrying`);\n    return syncClient(clientReq, pkg, true);\n  }\n}\n\nasync function apiCall(sso: Partial<Sso>, method = \"POST\", authToken = \"\") {\n  // Handle single test mode\n  if (UDSConfig.isSingleTest) {\n    Log.warn(`Generating fake client for '${sso.clientId}' in single test mode`);\n    return {\n      ...sso,\n      secret: sso.secret || \"fake-secret\",\n      registrationAccessToken: \"fake-registration-access-token\",\n    } as Client;\n  }\n\n  const req = {\n    body: JSON.stringify(sso) as string | undefined,\n    method,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    } as Record<string, string>,\n  };\n\n  let url = apiURL;\n\n  // When not creating a new client, add the client ID and registrationAccessToken\n  if (authToken) {\n    req.headers.Authorization = `Bearer ${authToken}`;\n    url += `/${sso.clientId}`;\n  }\n\n  // Remove the body for DELETE requests\n  if (method === \"DELETE\") {\n    delete req.body;\n  }\n\n  // Make the request\n  const resp = await fetch<Client>(url, req);\n\n  if (!resp.ok) {\n    throw new Error(`Failed to ${method} client: ${resp.statusText}`);\n  }\n\n  return resp.data;\n}\n\nexport function generateSecretData(client: Client, secretTemplate?: { [key: string]: string }) {\n  if (secretTemplate) {\n    Log.debug(`Using secret template for client: ${client.clientId}`);\n    // Iterate over the secret template entry and process each value\n    return templateData(secretTemplate, client);\n  }\n\n  const stringMap: Record<string, string> = {};\n\n  Log.debug(`Using client data for secret: ${client.clientId}`);\n\n  // iterate over the client object and convert all values to strings\n  for (const [key, value] of Object.entries(client)) {\n    // For objects and arrays, convert to a JSON string\n    const processed = typeof value === \"object\" ? JSON.stringify(value) : String(value);\n\n    // Convert the value to a base64 encoded string\n    stringMap[key] = Buffer.from(processed).toString(\"base64\");\n  }\n\n  return stringMap;\n}\n\n/**\n * Process the secret template and convert the client data to base64 encoded strings for use in a secret\n *\n * @param secretTemplate The template to use for generating the secret\n * @param client\n * @returns\n */\nfunction templateData(secretTemplate: { [key: string]: string }, client: Client) {\n  const stringMap: Record<string, string> = {};\n\n  // Iterate over the secret template and process each entry\n  for (const [key, value] of Object.entries(secretTemplate)) {\n    // Replace any clientField() references with the actual client data\n    const templated = value.replace(\n      secretTemplateRegex,\n      (_match, fieldName: keyof Client, key, json) => {\n        // Make typescript happy with a more generic type\n        const value = client[fieldName] as Record<string | number, string> | string;\n\n        // If a key is provided, use it to get the value\n        if (key) {\n          return String(value[key] ?? \"\");\n        }\n\n        // If .json() is provided, convert the value to a JSON string\n        if (json) {\n          return JSON.stringify(value);\n        }\n\n        // Otherwise, convert the value to a string\n        return value !== undefined ? String(value) : \"\";\n      },\n    );\n\n    // Convert the templated value to a base64 encoded string\n    stringMap[key] = Buffer.from(templated).toString(\"base64\");\n  }\n\n  // Return the processed secret template without any further processing\n  return stringMap;\n}\n", "import { Log } from \"pepr\";\n\nlet domain = process.env.UDS_DOMAIN;\n\n// We need to handle `npx pepr <>` commands that will not template the env vars\nif (!domain || domain === \"###ZARF_VAR_DOMAIN###\") {\n  domain = \"uds.dev\";\n}\n\nexport const UDSConfig = {\n  // Ignore the UDS_DOMAIN if not deployed by Zarf\n  domain,\n  // Track if we are running a single test mode\n  isSingleTest: process.env.UDS_SINGLE_TEST === \"true\",\n  // Allow UDS policy exemptions to be used in any namespace\n  allowAllNSExemptions: process.env.UDS_ALLOW_ALL_NS_EXEMPTIONS === \"true\",\n};\n\nLog.info(UDSConfig, \"Loaded UDS Config\");\n\nif (UDSConfig.isSingleTest) {\n  Log.warn(\n    \"Running in single test mode, this will change the behavior of the operator and should only be used for UDS Core development testing.\",\n  );\n}\n", "import { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { GenericKind } from \"kubernetes-fluent-client\";\n\n/**\n * Sanitize a resource name to make it a valid Kubernetes resource name.\n *\n * @param name the name of the resource to sanitize\n * @returns the sanitized resource name\n */\nexport function sanitizeResourceName(name: string) {\n  return (\n    name\n      // The name must be lowercase\n      .toLowerCase()\n      // Replace sequences of non-alphanumeric characters with a single '-'\n      .replace(/[^a-z0-9]+/g, \"-\")\n      // Truncate the name to 250 characters\n      .slice(0, 250)\n      // Remove leading and trailing non-letter characters\n      .replace(/^[^a-z]+|[^a-z]+$/g, \"\")\n  );\n}\n\n/**\n * Get the owner reference for a custom resource\n * @param cr the custom resource to get the owner reference for\n * @returns the owner reference for the custom resource\n */\nexport function getOwnerRef(cr: GenericKind): V1OwnerReference[] {\n  const { name, uid } = cr.metadata!;\n\n  return [\n    {\n      apiVersion: cr.apiVersion!,\n      kind: cr.kind!,\n      uid: uid!,\n      name: name!,\n    },\n  ];\n}\n", "import { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\nimport { K8s, Log, R, kind } from \"pepr\";\n\nimport { RemoteGenerated } from \"../../../crd\";\nimport { anywhere } from \"./anywhere\";\n\n// This is an in-memory cache of the API server CIDR\nlet apiServerPeers: V1NetworkPolicyPeer[];\n\n/**\n * Initialize the API server CIDR by getting the EndpointSlice and Service for the API server\n */\nexport async function initAPIServerCIDR() {\n  const slice = await K8s(kind.EndpointSlice).InNamespace(\"default\").Get(\"kubernetes\");\n  const svc = await K8s(kind.Service).InNamespace(\"default\").Get(\"kubernetes\");\n  await updateAPIServerCIDR(slice, svc);\n}\n\n/**\n * Get the API server CIDR\n * @returns The API server CIDR\n */\nexport function kubeAPI() {\n  // If the API server peers are already cached, return them\n  if (apiServerPeers) {\n    return apiServerPeers;\n  }\n\n  // Otherwise, log a warning and default to 0.0.0.0/0 until the EndpointSlice is updated\n  Log.warn(\"Unable to get API server CIDR, defaulting to 0.0.0.0/0\");\n  return [anywhere];\n}\n\n/**\n * When the kubernetes EndpointSlice is created or updated, update the API server CIDR\n * @param slice The EndpointSlice for the API server\n */\nexport async function updateAPIServerCIDRFromEndpointSlice(slice: kind.EndpointSlice) {\n  const svc = await K8s(kind.Service).InNamespace(\"default\").Get(\"kubernetes\");\n  await updateAPIServerCIDR(slice, svc);\n}\n\n/**\n * When the kubernetes Service is created or updated, update the API server CIDR\n * @param svc The Service for the API server\n */\nexport async function updateAPIServerCIDRFromService(svc: kind.Service) {\n  const slice = await K8s(kind.EndpointSlice).InNamespace(\"default\").Get(\"kubernetes\");\n  await updateAPIServerCIDR(slice, svc);\n}\n\n/**\n * Update the API server CIDR and update the NetworkPolicies\n *\n * @param slice The EndpointSlice for the API server\n * @param svc The Service for the API server\n */\nexport async function updateAPIServerCIDR(slice: kind.EndpointSlice, svc: kind.Service) {\n  const { endpoints } = slice;\n  const k8sApiIP = svc.spec?.clusterIP;\n\n  // Flatten the endpoints into a list of IPs\n  const peers = endpoints?.flatMap(e => e.addresses);\n\n  if (k8sApiIP) {\n    peers?.push(k8sApiIP);\n  }\n\n  // If the peers are found, cache and process them\n  if (peers?.length) {\n    apiServerPeers = peers.flatMap(ip => ({\n      ipBlock: {\n        cidr: `${ip}/32`,\n      },\n    }));\n\n    // Get all the KubeAPI NetworkPolicies\n    const netPols = await K8s(kind.NetworkPolicy)\n      .WithLabel(\"uds.dev/generated\", RemoteGenerated.KubeAPI)\n      .Get();\n\n    for (const netPol of netPols.items) {\n      // Get the old peers\n      const oldPeers = netPol.spec?.egress?.[0].to;\n\n      // Update the NetworkPolicy if the peers have changed\n      if (!R.equals(oldPeers, apiServerPeers)) {\n        // Note using the apiServerPeers variable here instead of the oldPeers variable\n        // in case another EndpointSlice is updated before this one\n        netPol.spec!.egress![0].to = apiServerPeers;\n\n        Log.debug(`Updating ${netPol.metadata!.namespace}/${netPol.metadata!.name}`);\n        await K8s(kind.NetworkPolicy).Apply(netPol);\n      }\n    }\n  }\n}\n", "import { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\n\nexport const META_IP = \"169.254.169.254/32\";\n\n/**\n * The cloud metadata endpoint is a common cloud address that can be used to\n * access cloud provider metadata.\n *\n * AWS: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html\n *\n * GCP: https://cloud.google.com/compute/docs/storing-retrieving-metadata\n *\n * Azure: https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service\n *\n * DigitalOcean: https://www.digitalocean.com/docs/droplets/resources/metadata/\n *\n * @returns A NetworkPolicyPeer that matches the cloud metadata service\n */\nexport const cloudMetadata: V1NetworkPolicyPeer[] = [\n  {\n    ipBlock: { cidr: META_IP },\n  },\n];\n", "import { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\nimport { META_IP } from \"./cloudMetadata\";\n\n/** Matches any endpoint EXCEPT the Cloud Meta endpoint */\nexport const anywhere: V1NetworkPolicyPeer = {\n  ipBlock: {\n    cidr: \"0.0.0.0/0\",\n    except: [META_IP],\n  },\n};\n", "import { PeprValidateRequest } from \"pepr\";\nimport { MatcherKind, Policy, UDSExemption } from \"..\";\nimport { UDSConfig } from \"../../../config\";\n\nfunction checkForSlashes(name: string) {\n  return name[0] === \"/\" && name[name.length - 1] === \"/\";\n}\n\nconst validNs = \"uds-policy-exemptions\";\nconst kindToPolicyMap = new Map<MatcherKind, Policy[]>([\n  [\n    MatcherKind.Pod,\n    Object.values(Policy).filter(\n      p => p != Policy.DisallowNodePortServices && p != Policy.RestrictExternalNames,\n    ),\n  ],\n  [MatcherKind.Service, [Policy.RestrictExternalNames, Policy.DisallowNodePortServices]],\n]);\n\nexport async function exemptValidator(req: PeprValidateRequest<UDSExemption>) {\n  const exempt = req.Raw;\n  const exemptions = exempt.spec?.exemptions ?? [];\n\n  // Validate exemption namespace is uds-policy-exempts unless allowAllNSExemptions is true\n  if (!UDSConfig.allowAllNSExemptions) {\n    if (exempt.metadata?.namespace !== validNs) {\n      return req.Deny(\n        `Invalid namespace \"${exempt.metadata?.namespace}\" for UDSExemption ${exempt.metadata?.name}: must be \"${validNs}\"`,\n      );\n    }\n  }\n\n  // Validate there's at least 1 exemption element\n  if (exemptions.length === 0) {\n    return req.Deny(\"Invalid number of exemptions: must have at least 1\");\n  }\n\n  // Validate exemption element policies and matcher kind are compatible\n  for (const e of exemptions) {\n    const policies = kindToPolicyMap.get(e.matcher.kind!)!;\n    for (const p of e.policies) {\n      if (!policies.includes(p)) {\n        const validKind =\n          e.matcher.kind === MatcherKind.Pod ? MatcherKind.Service : MatcherKind.Pod;\n        return req.Deny(\n          `Invalid kind \"${e.matcher.kind}\" for matcher \"${e.matcher.name}\" with policy \"${p}\": \"${p}\" can only be exempted for kind \"${validKind}\"`,\n        );\n      }\n    }\n  }\n\n  // Validate that each matcher name does not contain leading or trailing slashes and is a valid regex pattern\n  for (const e of exemptions) {\n    if (checkForSlashes(e.matcher.name)) {\n      return req.Deny(\n        `Invalid matcher name \"${e.matcher.name}\": please remove the leading and trailing slashes`,\n      );\n    }\n\n    try {\n      new RegExp(e.matcher.name);\n    } catch (err) {\n      return req.Deny(`Invalid regular expression pattern ${e.matcher.name}: ${err}`);\n    }\n  }\n\n  return req.Approve();\n}\n", "import { K8s, Log } from \"pepr\";\n\nimport { UDSConfig } from \"../../../config\";\nimport { Expose, Gateway, Istio, UDSPackage } from \"../../crd\";\nimport { getOwnerRef, sanitizeResourceName } from \"../utils\";\n\n/**\n * Creates a VirtualService for each exposed service in the package\n *\n * @param pkg\n * @param namespace\n */\nexport async function virtualService(pkg: UDSPackage, namespace: string) {\n  const pkgName = pkg.metadata!.name!;\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n\n  // Get the list of exposed services\n  const exposeList = pkg.spec?.network?.expose ?? [];\n\n  // Create a list of generated VirtualServices\n  const payloads: Istio.VirtualService[] = [];\n\n  // Iterate over each exposed service\n  for (const expose of exposeList) {\n    const { gateway = Gateway.Tenant, host, port, service, advancedHTTP = {} } = expose;\n\n    const name = generateVSName(pkg, expose);\n\n    // For the admin gateway, we need to add the path prefix\n    const domain = (gateway === Gateway.Admin ? \"admin.\" : \"\") + UDSConfig.domain;\n\n    // Append the domain to the host\n    const fqdn = `${host}.${domain}`;\n\n    const http: Istio.HTTP = { ...advancedHTTP };\n\n    // Create the route to the service\n    const route: Istio.HTTPRoute[] = [\n      {\n        destination: {\n          // Use the service name as the host\n          host: `${service}.${namespace}.svc.cluster.local`,\n          // The CRD only uses numeric ports\n          port: { number: port },\n        },\n      },\n    ];\n\n    if (!advancedHTTP.directResponse) {\n      // Create the route to the service if not using advancedHTTP.directResponse\n      http.route = route;\n    }\n\n    const payload: Istio.VirtualService = {\n      metadata: {\n        name,\n        namespace,\n        labels: {\n          \"uds/package\": pkgName,\n          \"uds/generation\": generation,\n        },\n        // Use the CR as the owner ref for each VirtualService\n        ownerReferences: getOwnerRef(pkg),\n      },\n      spec: {\n        // Append the UDS Domain to the host\n        hosts: [fqdn],\n        // Map the gateway (admin, passthrough or tenant) to the VirtualService\n        gateways: [`istio-${gateway}-gateway/${gateway}-gateway`],\n        // Apply the route to the VirtualService\n        http: [http],\n      },\n    };\n\n    // If the gateway is the passthrough gateway, apply the TLS match\n    if (gateway === Gateway.Passthrough) {\n      payload.spec!.tls = [\n        {\n          match: [{ port: 443, sniHosts: [fqdn] }],\n          route,\n        },\n      ];\n    }\n\n    Log.debug(payload, `Applying VirtualService ${name}`);\n\n    // Apply the VirtualService and force overwrite any existing policy\n    await K8s(Istio.VirtualService).Apply(payload, { force: true });\n\n    payloads.push(payload);\n  }\n\n  // Get all related VirtualServices in the namespace\n  const virtualServices = await K8s(Istio.VirtualService)\n    .InNamespace(namespace)\n    .WithLabel(\"uds/package\", pkgName)\n    .Get();\n\n  // Find any orphaned VirtualServices (not matching the current generation)\n  const orphanedVS = virtualServices.items.filter(\n    vs => vs.metadata?.labels?.[\"uds/generation\"] !== generation,\n  );\n\n  // Delete any orphaned VirtualServices\n  for (const vs of orphanedVS) {\n    Log.debug(vs, `Deleting orphaned VirtualService ${vs.metadata!.name}`);\n    await K8s(Istio.VirtualService).Delete(vs);\n  }\n\n  // Return the list of unique hostnames\n  return [...new Set(payloads.map(v => v.spec!.hosts!).flat())];\n}\n\nexport function generateVSName(pkg: UDSPackage, expose: Expose) {\n  const { gateway = Gateway.Tenant, host, port, service, description, advancedHTTP } = expose;\n\n  // Ensure the resource name is valid\n  const matchHash = advancedHTTP?.match?.flatMap(m => m.name).join(\"-\") || \"\";\n  const nameSuffix = description || `${host}-${port}-${service}-${matchHash}`;\n  const name = sanitizeResourceName(`${pkg.metadata!.name}-${gateway}-${nameSuffix}`);\n\n  return name;\n}\n", "import { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\n\n/** Matches any pod in the namespace */\nexport const intraNamespace: V1NetworkPolicyPeer = {\n  podSelector: {\n    matchLabels: {},\n  },\n};\n", "import { V1LabelSelector, V1NetworkPolicyPeer, V1NetworkPolicyPort } from \"@kubernetes/client-node\";\nimport { kind } from \"pepr\";\n\nimport { Allow, RemoteGenerated } from \"../../crd\";\nimport { anywhere } from \"./generators/anywhere\";\nimport { cloudMetadata } from \"./generators/cloudMetadata\";\nimport { intraNamespace } from \"./generators/intraNamespace\";\nimport { kubeAPI } from \"./generators/kubeAPI\";\n\nexport function generate(namespace: string, policy: Allow): kind.NetworkPolicy {\n  // Create a unique name for the NetworkPolicy based on the package name, index, direction, pod labels, and port\n  const name = generateName(policy);\n\n  // Create the NetworkPolicy\n  const generated: kind.NetworkPolicy = {\n    apiVersion: \"networking.k8s.io/v1\",\n    kind: \"NetworkPolicy\",\n    metadata: {\n      name,\n      namespace,\n      labels: { ...policy.labels },\n    },\n    spec: {\n      policyTypes: [policy.direction],\n      podSelector: {\n        matchLabels: policy.selector,\n      },\n    },\n  };\n\n  // Add the description if it exists to the annotations in case of truncation of the name\n  if (policy.description) {\n    generated.metadata!.annotations = {\n      \"uds/description\": policy.description,\n    };\n  }\n\n  // Create the remote (peer) to match against\n  let peers: V1NetworkPolicyPeer[] = [];\n\n  // Add the remoteNamespace if they exist\n  if (policy.remoteNamespace !== undefined) {\n    const namespaceSelector: V1LabelSelector = {};\n\n    // Add the remoteNamespace to the namespaceSelector if it exists and is not \"*\", otherwise match all namespaces\n    if (policy.remoteNamespace !== \"\" && policy.remoteNamespace !== \"*\") {\n      namespaceSelector.matchLabels = {\n        \"kubernetes.io/metadata.name\": policy.remoteNamespace,\n      };\n    }\n\n    // Add the remoteNamespace to the peers\n    peers.push({ namespaceSelector });\n  }\n\n  // Add the remoteSelector if they exist\n  if (policy.remoteSelector) {\n    peers.push({\n      podSelector: {\n        matchLabels: policy.remoteSelector,\n      },\n    });\n  }\n\n  // Check if remoteGenerated is set\n  if (policy.remoteGenerated) {\n    // Add the remoteGenerated label\n    generated.metadata!.labels![\"uds/generated\"] = policy.remoteGenerated;\n\n    // Check if remoteGenerated is set\n    switch (policy.remoteGenerated) {\n      case RemoteGenerated.KubeAPI:\n        peers = kubeAPI();\n        break;\n\n      case RemoteGenerated.CloudMetadata:\n        peers = cloudMetadata;\n        break;\n\n      case RemoteGenerated.IntraNamespace:\n        peers.push(intraNamespace);\n        break;\n\n      case RemoteGenerated.Anywhere:\n        peers = [anywhere];\n        break;\n    }\n  }\n\n  // Define the ports to allow from the ports property\n  const ports: V1NetworkPolicyPort[] = (policy.ports ?? []).map(port => ({ port }));\n\n  // Add the individual port if it exists\n  if (policy.port) {\n    ports.push({\n      port: policy.port,\n    });\n  }\n\n  // Add the ingress or egress rule\n  switch (policy.direction) {\n    case \"Ingress\":\n      generated.spec!.ingress = [{ from: peers, ports }];\n      break;\n\n    case \"Egress\":\n      generated.spec!.egress = [{ to: peers, ports }];\n      break;\n  }\n\n  return generated;\n}\n\n/**\n * Generates a unique name for the NetworkPolicy based on the description, direction, and combination of remote properties\n *\n * @param policy the name of the policy\n */\nexport function generateName(policy: Allow) {\n  const name =\n    // Use the description if it exists\n    policy.description ||\n    // Otherwise use the direction, and combination of remote properties\n    [\n      Object.values(policy.selector || [\"all pods\"]),\n      policy.remoteGenerated || [\n        policy.remoteNamespace,\n        Object.values(policy.remoteSelector || [\"all pods\"]),\n      ],\n    ]\n      // Flatten the array\n      .flat(1)\n      .join(\"-\");\n\n  return `${policy.direction}-${name}`;\n}\n", "import { UDSPackage } from \".\";\n\n/**\n * Migrates the package to the latest version\n *\n * @param pkg the package to migrate\n * @returns\n */\nexport function migrate(pkg: UDSPackage) {\n  const exposeList = pkg.spec?.network?.expose ?? [];\n\n  for (const expose of exposeList) {\n    // Migrate expose[].match -> expose[].advancedHTTP.match\n    if (expose.match) {\n      expose.advancedHTTP = expose.advancedHTTP ?? {};\n      expose.advancedHTTP.match = expose.match;\n      delete expose.match;\n    }\n  }\n\n  const allowList = pkg.spec?.network?.allow ?? [];\n\n  for (const allow of allowList) {\n    // Migrate allow[].podLabels -> allow[].selector\n    if (allow.podLabels) {\n      allow.selector = allow.podLabels;\n      delete allow.podLabels;\n    }\n\n    // Migrate allow[].remotePodLabels -> allow[].remoteSelector\n    if (allow.remotePodLabels) {\n      allow.remoteSelector = allow.remotePodLabels;\n      delete allow.remotePodLabels;\n    }\n  }\n\n  return pkg;\n}\n", "import { PeprValidateRequest } from \"pepr\";\n\nimport { Gateway, UDSPackage } from \"..\";\nimport { generateVSName } from \"../../controllers/istio/virtual-service\";\nimport { generateName } from \"../../controllers/network/generate\";\nimport { sanitizeResourceName } from \"../../controllers/utils\";\nimport { migrate } from \"../migrate\";\n\nconst invalidNamespaces = [\"kube-system\", \"kube-public\", \"_unknown_\", \"pepr-system\"];\n\nexport async function validator(req: PeprValidateRequest<UDSPackage>) {\n  const pkg = migrate(req.Raw);\n\n  const ns = pkg.metadata?.namespace ?? \"_unknown_\";\n\n  if (invalidNamespaces.includes(ns)) {\n    return req.Deny(\"invalid namespace\");\n  }\n\n  const exposeList = pkg.spec?.network?.expose ?? [];\n\n  // Track the names of the virtual services to ensure they are unique\n  const virtualServiceNames = new Set<string>();\n\n  for (const expose of exposeList) {\n    if (expose.gateway === Gateway.Passthrough) {\n      if (expose.advancedHTTP) {\n        return req.Deny(\"advancedHTTP cannot be used with passthrough gateway\");\n      }\n    }\n\n    // directResponse cannot be combined with service, port or pod configs\n    if (\n      expose.advancedHTTP?.directResponse &&\n      (expose.service || expose.selector || expose.port || expose.targetPort)\n    ) {\n      return req.Deny(\"directResponse cannot be combined with service, port, selector, targetPort\");\n    }\n\n    // Ensure the service name is unique\n    const name = generateVSName(req.Raw, expose);\n    if (virtualServiceNames.has(name)) {\n      return req.Deny(\n        `The combination of characteristics of this expose entry would create a duplicate VirtualService. ` +\n          `Verify you do not have duplicate values, or add a unique \"description\" field for this rule. ` +\n          `The duplicate rule would be named \"${name}\".`,\n      );\n    }\n\n    // Add the name to the set to track it\n    virtualServiceNames.add(name);\n  }\n\n  const networkPolicy = pkg.spec?.network?.allow ?? [];\n\n  // Track the names of the network policies to ensure they are unique\n  const networkPolicyNames = new Set<string>();\n\n  for (const policy of networkPolicy) {\n    // remoteGenerated cannot be combined with remoteNamespace or remoteSelector\n    if (policy.remoteGenerated && (policy.remoteNamespace || policy.remoteSelector)) {\n      return req.Deny(\"remoteGenerated cannot be combined with remoteNamespace or remoteSelector\");\n    }\n\n    // Ensure the policy name is unique\n    const name = sanitizeResourceName(`allow-${pkg.metadata?.name}-${generateName(policy)}`);\n    if (networkPolicyNames.has(name)) {\n      return req.Deny(\n        `The combination of characteristics of this network allow rule would create a duplicate NetworkPolicy. ` +\n          `Verify you do not have duplicate allow rules, or add a unique \"description\" field for this rule. ` +\n          `The duplicate rule would be named \"${name}\".`,\n      );\n    }\n    // Add the name to the set to track it\n    networkPolicyNames.add(name);\n  }\n\n  const ssoClients = pkg.spec?.sso ?? [];\n\n  // Ensure the client IDs are unique\n  const clientIDs = new Set<string>();\n\n  for (const client of ssoClients) {\n    if (clientIDs.has(client.clientId)) {\n      return req.Deny(`The client ID \"${client.clientId}\" is not unique`);\n    }\n    clientIDs.add(client.clientId);\n  }\n\n  return req.Approve();\n}\n", "import { Log } from \"pepr\";\n\nimport { handleFailure, shouldSkip, updateStatus } from \".\";\nimport { processExemptions } from \"../controllers/exemptions/exemptions\";\nimport { Phase, UDSExemption } from \"../crd\";\n\nexport async function exemptReconciler(exempt: UDSExemption) {\n  if (shouldSkip(exempt)) {\n    return;\n  }\n\n  const metadata = exempt.metadata!;\n  const { namespace, name } = metadata;\n\n  Log.debug(exempt, `Processing Exemption ${namespace}/${name}`);\n\n  try {\n    // Mark the exemption as pending\n    await updateStatus(exempt, { phase: Phase.Pending });\n\n    // Process the exemptions\n    processExemptions(exempt);\n\n    // Mark the exemption as ready\n    await updateStatus(exempt, {\n      phase: Phase.Ready,\n      observedGeneration: metadata.generation,\n      titles: exempt.spec?.exemptions?.map(e => e.title || e.matcher.name),\n    });\n  } catch (err) {\n    // Handle the failure\n    void handleFailure(err, exempt);\n  }\n}\n", "import { GenericKind } from \"kubernetes-fluent-client\";\nimport { K8s, Log, kind } from \"pepr\";\n\nimport { ExemptStatus, Phase, PkgStatus, UDSExemption, UDSPackage } from \"../crd\";\nimport { Status } from \"../crd/generated/package-v1alpha1\";\n\nconst uidSeen = new Set<string>();\n\n/**\n * Checks if the CRD is pending or the current generation has been processed\n *\n * @param cr The custom resource to check\n * @returns true if the CRD is pending or the current generation has been processed\n */\nexport function shouldSkip(cr: UDSExemption | UDSPackage) {\n  const isPending = cr.status?.phase === Phase.Pending;\n  const isCurrentGeneration = cr.metadata?.generation === cr.status?.observedGeneration;\n\n  // First check if the CR has been seen before and return false if it has not\n  // This ensures that all CRs are processed at least once during the lifetime of the pod\n  if (!uidSeen.has(cr.metadata!.uid!)) {\n    Log.debug(cr, `Should skip? No, first time processed during this pod's lifetime`);\n    uidSeen.add(cr.metadata!.uid!);\n    return false;\n  }\n\n  // This is the second time the CR has been seen, so check if it is pending or the current generation\n  if (isPending || isCurrentGeneration) {\n    Log.debug(cr, `Should skip? Yes, pending or current generation and not first time seen`);\n    return true;\n  }\n\n  Log.debug(cr, `Should skip? No, not pending or current generation and not first time seen`);\n\n  return false;\n}\n\n/**\n * Updates the status of the package\n *\n * @param cr The custom resource to update\n * @param status The new status\n */\nexport async function updateStatus(cr: GenericKind, status: PkgStatus | ExemptStatus) {\n  const model = cr.kind === \"Package\" ? UDSPackage : UDSExemption;\n  Log.debug(cr.metadata, `Updating status to ${status.phase}`);\n\n  // Update the status of the CRD\n  await K8s(model).PatchStatus({\n    metadata: {\n      name: cr.metadata!.name,\n      namespace: cr.metadata!.namespace,\n    },\n    status,\n  });\n}\n\n/**\n * Write a K8s event for the CRD\n *\n * @param cr The custom resource to write the event for\n * @param message A human-readable message for the event\n * @param type The type of event to write\n */\nexport async function writeEvent(cr: GenericKind, event: Partial<kind.CoreEvent>) {\n  Log.debug(cr.metadata, `Writing event: ${event.message}`);\n\n  await K8s(kind.CoreEvent).Create({\n    type: \"Warning\",\n    reason: \"ReconciliationFailed\",\n    ...event,\n    // Fixed values\n    metadata: {\n      namespace: cr.metadata!.namespace,\n      generateName: cr.metadata!.name,\n    },\n    involvedObject: {\n      apiVersion: cr.apiVersion,\n      kind: cr.kind,\n      name: cr.metadata!.name,\n      namespace: cr.metadata!.namespace,\n      uid: cr.metadata!.uid,\n    },\n    firstTimestamp: new Date(),\n    reportingComponent: \"uds.dev/operator\",\n    reportingInstance: process.env.HOSTNAME,\n  });\n}\n\n/**\n * Handles a failure by updating the status of the CRD and writing an event\n *\n * @param err The error-like object\n * @param cr The custom resource that failed\n */\nexport async function handleFailure(\n  err: { status: number; message: string },\n  cr: UDSPackage | UDSExemption,\n) {\n  const metadata = cr.metadata!;\n  const identifier = `${metadata.namespace}/${metadata.name}`;\n\n  if (err.status === 404) {\n    Log.warn({ err }, `Package metadata seems to have been deleted`);\n    return;\n  }\n\n  Log.error({ err }, `Error configuring ${identifier}`);\n\n  // todo: need to evaluate when it is safe to retry (updating generation now avoids retrying infinitely)\n  const status = {\n    phase: Phase.Failed,\n    observedGeneration: metadata.generation,\n  } as Status;\n\n  // Write an event for the error\n  void writeEvent(cr, { message: err.message });\n\n  // Update the status of the package with the error\n  updateStatus(cr, status).catch(finalErr => {\n    // If the status update fails, write log the error and and try to write an event\n    Log.error({ err: finalErr }, `Error updating status for ${identifier} failed`);\n    void writeEvent(cr, { message: finalErr.message });\n  });\n}\n", "import { Log } from \"pepr\";\n\nimport { handleFailure, shouldSkip, updateStatus } from \".\";\nimport { UDSConfig } from \"../../config\";\nimport { enableInjection } from \"../controllers/istio/injection\";\nimport { virtualService } from \"../controllers/istio/virtual-service\";\nimport { keycloak } from \"../controllers/keycloak/client-sync\";\nimport { networkPolicies } from \"../controllers/network/policies\";\nimport { Phase, UDSPackage } from \"../crd\";\nimport { migrate } from \"../crd/migrate\";\n\n/**\n * The reconciler is called from the queue and is responsible for reconciling the state of the package\n * with the cluster. This includes creating the namespace, network policies and virtual services.\n *\n * @param pkg the package to reconcile\n */\nexport async function packageReconciler(pkg: UDSPackage) {\n  const metadata = pkg.metadata!;\n  const { namespace, name } = metadata;\n\n  Log.info(pkg, `Processing Package ${namespace}/${name}`);\n\n  if (shouldSkip(pkg)) {\n    Log.info(pkg, `Skipping Package ${namespace}/${name}`);\n    return;\n  }\n\n  // Migrate the package to the latest version\n  migrate(pkg);\n\n  // Configure the namespace and namespace-wide network policies\n  try {\n    await updateStatus(pkg, { phase: Phase.Pending });\n\n    const netPol = await networkPolicies(pkg, namespace!);\n\n    // Only configure the VirtualService if not running in single test mode\n    let endpoints: string[] = [];\n    if (!UDSConfig.isSingleTest) {\n      // Update the namespace to ensure the istio-injection label is set\n      await enableInjection(pkg);\n\n      // Create the VirtualService for each exposed service\n      endpoints = await virtualService(pkg, namespace!);\n    } else {\n      Log.warn(`Running in single test mode, skipping ${name} VirtualService.`);\n    }\n\n    // Configure SSO\n    const ssoClients = await keycloak(pkg);\n\n    await updateStatus(pkg, {\n      phase: Phase.Ready,\n      ssoClients,\n      endpoints,\n      networkPolicyCount: netPol.length,\n      observedGeneration: metadata.generation,\n    });\n  } catch (err) {\n    void handleFailure(err, pkg);\n  }\n}\n", "import { K8s, Log, kind } from \"pepr\";\n\nimport { Allow, Direction, Gateway, UDSPackage } from \"../../crd\";\nimport { getOwnerRef, sanitizeResourceName } from \"../utils\";\nimport { allowEgressDNS } from \"./defaults/allow-egress-dns\";\nimport { allowEgressIstiod } from \"./defaults/allow-egress-istiod\";\nimport { allowIngressSidecarMonitoring } from \"./defaults/allow-ingress-sidecar-monitoring\";\nimport { defaultDenyAll } from \"./defaults/default-deny-all\";\nimport { generate } from \"./generate\";\n\nexport async function networkPolicies(pkg: UDSPackage, namespace: string) {\n  const customPolicies = pkg.spec?.network?.allow ?? [];\n  const pkgName = pkg.metadata!.name!;\n\n  // Get the current generation of the package\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n\n  Log.debug(pkg.metadata, `Generating NetworkPolicies for generation ${generation}`);\n\n  const policies = [\n    // All traffic must be explicitly allowed\n    defaultDenyAll(namespace),\n\n    // Allow DNS lookups\n    allowEgressDNS(namespace),\n\n    // Istio rules\n    allowEgressIstiod(namespace),\n    allowIngressSidecarMonitoring(namespace),\n  ];\n\n  // Process custom policies\n  for (const policy of customPolicies) {\n    const generatedPolicy = generate(namespace, policy);\n    policies.push(generatedPolicy);\n  }\n\n  // Generate NetworkPolicies for any VirtualServices that are generated\n  const exposeList = pkg.spec?.network?.expose ?? [];\n  // Iterate over each exposed service, excluding directResponse services\n  for (const expose of exposeList.filter(exp => !exp.advancedHTTP?.directResponse)) {\n    const { gateway = Gateway.Tenant, port, selector = {}, targetPort } = expose;\n\n    // Create the NetworkPolicy for the VirtualService\n    const policy: Allow = {\n      direction: Direction.Ingress,\n      selector,\n      remoteNamespace: `istio-${gateway}-gateway`,\n      remoteSelector: {\n        app: `${gateway}-ingressgateway`,\n      },\n      // Use the same port as the VirtualService if targetPort is not set\n      port: targetPort ?? port,\n      description: `${Object.values(selector)} Istio ${gateway} gateway`,\n    };\n\n    // Generate the policy\n    const generatedPolicy = generate(namespace, policy);\n    policies.push(generatedPolicy);\n  }\n\n  // Iterate over each policy and apply it\n  for (const [idx, policy] of policies.entries()) {\n    // Add the package name and generation to the labels\n    policy.metadata = policy.metadata ?? {};\n    policy.metadata.labels = policy.metadata?.labels ?? {};\n    policy.metadata.labels[\"uds/package\"] = pkgName;\n    policy.metadata.labels[\"uds/generation\"] = generation;\n\n    // Add the package name to the name of the policy to ensure uniqueness\n    if (idx < 1) {\n      policy.metadata.name = `deny-${pkgName}-${policy.metadata.name}`;\n    } else {\n      policy.metadata.name = `allow-${pkgName}-${policy.metadata.name}`;\n    }\n\n    // Ensure the name is a valid resource name\n    policy.metadata.name = sanitizeResourceName(policy.metadata.name);\n\n    // Use the CR as the owner ref for each NetworkPolicy\n    policy.metadata.ownerReferences = getOwnerRef(pkg);\n\n    // Apply the NetworkPolicy and force overwrite any existing policy\n    await K8s(kind.NetworkPolicy).Apply(policy, { force: true });\n  }\n\n  // Delete any policies that are no longer needed\n  const policyList = await K8s(kind.NetworkPolicy)\n    .InNamespace(namespace)\n    .WithLabel(\"uds/package\", pkgName)\n    .Get();\n\n  // Find any orphaned polices (not matching the current generation)\n  const orphanedNetPol = policyList.items.filter(\n    netPol => netPol.metadata?.labels?.[\"uds/generation\"] !== generation,\n  );\n\n  // Delete any orphaned policies\n  for (const netPol of orphanedNetPol) {\n    Log.debug(netPol, `Deleting orphaned NetworkPolicy ${netPol.metadata!.name}`);\n    await K8s(kind.NetworkPolicy).Delete(netPol);\n  }\n\n  // Return the list of policies\n  return policies;\n}\n", "import { Direction } from \"../../../crd\";\nimport { generate } from \"../generate\";\n\nexport const allowEgressDNS = (namespace: string) => {\n  const netPol = generate(namespace, {\n    direction: Direction.Egress,\n    description: \"DNS lookup via CoreDNS\",\n    remoteNamespace: \"kube-system\",\n    remoteSelector: {\n      \"k8s-app\": \"kube-dns\",\n    },\n    port: 53,\n  });\n\n  // Override the generated policy to use UDP instead of TCP\n  netPol.spec!.egress![0].ports![0].protocol = \"UDP\";\n\n  return netPol;\n};\n", "import { Direction } from \"../../../crd\";\nimport { generate } from \"../generate\";\n\nexport const allowEgressIstiod = (namespace: string) =>\n  generate(namespace, {\n    direction: Direction.Egress,\n    description: \"Istiod communication\",\n    remoteNamespace: \"istio-system\",\n    remoteSelector: {\n      istio: \"pilot\",\n    },\n    port: 15012,\n  });\n", "import { Direction } from \"../../../crd\";\nimport { generate } from \"../generate\";\n\nexport const allowIngressSidecarMonitoring = (namespace: string) =>\n  generate(namespace, {\n    direction: Direction.Ingress,\n    description: \"Sidecar monitoring\",\n    remoteNamespace: \"monitoring\",\n    remoteSelector: {\n      app: \"prometheus\",\n    },\n    port: 15020,\n  });\n", "import { kind } from \"pepr\";\n\nexport function defaultDenyAll(namespace: string): kind.NetworkPolicy {\n  return {\n    apiVersion: \"networking.k8s.io/v1\",\n    kind: \"NetworkPolicy\",\n    metadata: {\n      name: \"default\",\n      namespace,\n    },\n    spec: {\n      podSelector: {},\n      policyTypes: [\"Ingress\", \"Egress\"],\n      ingress: [],\n      egress: [],\n    },\n  };\n}\n"],
  "mappings": "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CA,oBACA,kBACA,sBACA,qBACF,CACF,CACF,EACA,QAAS,CACP,YAAa,8CACb,KAAM,SACN,SAAU,CAAC,YAAa,MAAM,EAC9B,WAAY,CACV,UAAW,CACT,KAAM,QACR,EACA,KAAM,CACJ,KAAM,QACR,EACA,KAAM,CACJ,KAAM,SACN,KAAM,CAAC,MAAO,SAAS,EACvB,QAAS,KACX,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,ECpHA,IAAMC,GAAgB,CAAC,CAAE,SAAU,CAAC,OAAO,CAAE,EAAG,CAAE,SAAU,CAAC,QAAQ,CAAE,EAAG,CAAE,SAAU,CAAC,OAAO,CAAE,CAAC,EAC3FC,EAAgB,CACpB,MAAO,CACL,CACE,IAAK,CACH,MAAOD,EACT,CACF,EACA,GAAGA,EACL,EACA,WAAY,CACV,MAAO,CACL,KAAM,QACR,EACA,OAAQ,CACN,KAAM,QACR,EACA,MAAO,CACL,YAAa,2EACb,KAAM,QACR,CACF,EACA,KAAM,QACR,EAEaE,GAAkC,CAC7C,YAAa,wCACb,WAAY,CACV,WAAY,CACV,YAAa,+CACb,WAAY,CACV,iBAAkB,CAChB,YACE,4GACF,SAAU,GACV,KAAM,SACR,EACA,aAAc,CACZ,YAAa,sEACb,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,aAAc,CACZ,YAAa,uDACb,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,YAAa,CACX,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,aAAc,CACZ,YAAa,8CACb,MAAOD,EACP,KAAM,OACR,EACA,cAAe,CACb,YAAa,kEACb,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,OAAQ,CACN,YAAa,uEACb,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,eAAgB,CACd,YACE,0FACF,WAAY,CACV,KAAM,CACJ,YAAa,8CACb,MAAO,CACL,CACE,IAAK,CACH,MAAO,CACL,CACE,SAAU,CAAC,QAAQ,CACrB,EACA,CACE,SAAU,CAAC,OAAO,CACpB,CACF,CACF,CACF,EACA,CACE,SAAU,CAAC,QAAQ,CACrB,EACA,CACE,SAAU,CAAC,OAAO,CACpB,CACF,EACA,WAAY,CACV,MAAO,CACL,YAAa,yCACb,OAAQ,SACR,KAAM,QACR,EACA,OAAQ,CACN,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,OAAQ,CACN,YAAa,qDACb,KAAM,SACR,CACF,EACA,SAAU,CAAC,QAAQ,EACnB,KAAM,QACR,EACA,QAAS,CACP,WAAY,CACV,QAAS,CACP,WAAY,CACV,IAAK,CACH,qBAAsB,CACpB,KAAM,QACR,EACA,KAAM,QACR,EACA,OAAQ,CACN,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,IAAK,CACH,qBAAsB,CACpB,KAAM,QACR,EACA,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,SAAU,CACR,WAAY,CACV,IAAK,CACH,qBAAsB,CACpB,KAAM,QACR,EACA,KAAM,QACR,EACA,OAAQ,CACN,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,IAAK,CACH,qBAAsB,CACpB,KAAM,QACR,EACA,KAAM,QACR,CACF,EACA,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,MAAO,CACL,YACE,sGACF,MAAO,CACL,WAAY,CACV,cAAe,CACb,YAAa,uEACb,KAAM,SACR,EACA,OAAQA,EACR,KAAM,CACJ,YAAa,gCACb,KAAM,QACR,EACA,YAAa,CACX,qBAAsBA,EACtB,YAAa,iCACb,KAAM,QACR,EACA,IAAKA,CACP,EACA,SAAU,CAAC,MAAM,EACjB,KAAM,QACR,EACA,KAAM,OACR,EACA,QAAS,CACP,YAAa,2CACb,WAAY,CACV,UAAW,CACT,YAAa,qDACb,KAAM,QACR,EACA,IAAK,CACH,YAAa,uEACb,KAAM,QACR,EACA,gBAAiB,CACf,YAAa,gEACb,WAAY,CACV,MAAO,CACL,YACE,2EACF,KAAM,QACR,EACA,QAAS,CACP,YAAa,yEACb,KAAM,QACR,CACF,EACA,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,QAAS,CACP,YAAa,kCACb,WAAY,CACV,SAAU,CACR,YAAa,uDACb,OAAQ,QACR,KAAM,SACR,EACA,cAAe,CACb,YACE,uFACF,KAAM,QACR,EACA,QAAS,CACP,YAAa,0DACb,KAAM,QACR,EACA,sBAAuB,CACrB,YAAa,wEACb,SAAU,GACV,KAAM,SACR,CACF,EACA,KAAM,QACR,EACA,OAAQ,CACN,YACE,0FACF,OAAQ,QACR,KAAM,SACR,EACA,QAAS,CACP,YAAa,kDACb,KAAM,QACR,CACF,EACA,KAAM,QACR,ECvQA,IAAME,GAAQ,CACZ,YAAa,qEACb,KAAM,QACN,MAAO,CACL,KAAM,SACN,SAAU,CAAC,WAAW,EACtB,WAAY,CACV,OAAQ,CACN,YAAa,oCACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,YAAa,CACX,KAAM,SACN,YAAa,uEACf,EACA,UAAW,CACT,YAAa,+BACb,KAAM,CAAC,UAAW,QAAQ,EAC1B,KAAM,QACR,EACA,SAAU,CACR,YACE,kHACF,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,gBAAiB,CACf,YACE,+FACF,KAAM,QACR,EACA,eAAgB,CACd,YAAa,0DACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,gBAAiB,CACf,YAAa,kDACb,KAAM,SACN,KAAM,CAAC,UAAW,iBAAkB,gBAAiB,UAAU,CACjE,EACA,KAAM,CACJ,YAAa,6CACb,QAAS,EACT,QAAS,MACT,KAAM,QACR,EACA,MAAO,CACL,YAAa,oDACb,KAAM,QACN,MAAO,CACL,QAAS,EACT,QAAS,MACT,KAAM,QACR,CACF,EAEA,UAAW,CACT,YAAa,2BACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,gBAAiB,CACf,YAAa,iCACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,CACF,CACF,CACF,EAEMC,GAAS,CACb,KAAM,QACN,YAAa,uCACb,MAAO,CACL,KAAM,SACN,SAAU,CAAC,MAAM,EACjB,MAAO,CACL,CACE,SAAU,CAAC,UAAW,YAAa,MAAM,CAC3C,EACA,CACE,SAAU,CAAC,UAAW,WAAY,MAAM,CAC1C,EACA,CACE,SAAU,CAAC,cAAc,CAC3B,CACF,EACA,WAAY,CACV,YAAa,CACX,KAAM,SACN,YACE,sFACJ,EACA,KAAM,CACJ,YAAa,wCACb,KAAM,QACR,EACA,QAAS,CACP,YAAa,qEACb,KAAM,CAAC,QAAS,SAAU,aAAa,EACvC,KAAM,SACN,QAAS,QACX,EACA,QAAS,CACP,YAAa,oCACb,KAAM,QACR,EACA,KAAM,CACJ,YAAa,4BACb,QAAS,EACT,QAAS,MACT,KAAM,QACR,EACA,SAAU,CACR,YACE,kHACF,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,WAAY,CACV,YACE,8KACF,QAAS,EACT,QAAS,MACT,KAAM,QACR,EACA,aAAAC,GAEA,MAAO,CACL,YAAa,qCACb,GAAGA,GAAa,YAAY,KAC9B,EACA,UAAW,CACT,YAAa,2BACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,CACF,CACF,CACF,EAEMC,GAAM,CACV,YAAa,mCACb,KAAM,QACN,MAAO,CACL,KAAM,SACN,SAAU,CAAC,WAAY,OAAQ,cAAc,EAC7C,WAAY,CACV,gBAAiB,CACf,YAAa,sEACb,KAAM,UACN,QAAS,EACX,EACA,WAAY,CACV,YAAa,oDACb,KAAM,QACR,EACA,eAAgB,CACd,YAAa,sCAEb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,SAAU,CACR,YAAa,+DACb,KAAM,QACR,EACA,OAAQ,CACN,YAAa,8DACb,KAAM,QACR,EACA,KAAM,CACJ,YAAa,uCACb,KAAM,QACR,EACA,YAAa,CACX,YACE,mFACF,KAAM,QACR,EACA,QAAS,CACP,YAAa,qCACb,KAAM,QACR,EACA,aAAc,CACZ,YACE,0IACF,KAAM,QACN,MAAO,CACL,KAAM,QACR,EACA,SAAU,CACZ,EACA,WAAY,CACV,YACE,yKACF,KAAM,QACN,MAAO,CACL,KAAM,QACR,CACF,EACA,QAAS,CACP,YAAa,oCACb,KAAM,UACN,QAAS,EACX,EACA,uBAAwB,CACtB,YACE,+FACF,KAAM,UA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",
  "names": ["import_pepr", "package_default", "import_client_node", "import_pepr", "istio", "When", "inProgress", "pod", "name", "namespace", "key", "c", "kc", "err", "import_pepr", "import_pepr", "import_pepr", "v1alpha1", "matchRequired", "matchTemplate", "advancedHTTP", "allow", "expose", "advancedHTTP", "sso", "v1alpha1", "v1alpha1", "err", "operator", "Store", "When", "import_pepr", "import_pepr", "import_kubernetes_fluent_client", "Package", "__name", "Package", "import_kubernetes_fluent_client", "Exemption", "__name", "Policy", "Exemption", "virtualservice_v1beta1_exports", "__export", "DerivePort", "VirtualService", "import_kubernetes_fluent_client", "VirtualService", "__name", "DerivePort", "import_pepr", "policies", "Store", "When", "volumes", "request", "__name", "containers", "securityContextContainers", "c", "isIstioInitContainer", "securityContextMessage", "msg", "authorized", "ctx", "violations", "authMsg", "a", "container", "p", "transform", "policy", "annotateMutation", "import_pepr", "isExempt", "request", "policy", "exemptList", "Store", "exempt", "name", "__name", "markExemption", "When", "markExemption", "request", "isExempt", "violations", "securityContextContainers", "c", "securityContextMessage", "pod", "metadata", "runAsUser", "runAsGroup", "fsGroup", "annotateMutation", "isRoot", "__name", "ctx", "isRunAsRoot", "isRunAsRootUser", "podCtx", "authorized", "seLinuxOptions", "podSeLinuxType", "container", "containers", "import_pepr", "When", "markExemption", "request", "allowedVolumeTypes", "isExempt", "volume", "volumes", "volumeType", "key", "containers", "c", "mount", "import_pepr", "When", "markExemption", "request", "isExempt", "pod", "containers", "c", "p", "isSame", "__name", "a", "b", "addIfIncludesPolicy", "policy", "policyMap", "exemptionEl", "ownerId", "storedMatchers", "matcherToStore", "isDuplicate", "sm", "deleteIfPolicyRemoved", "matcher", "deleteIfMatchersRemoved", "currExemptMatchers", "policyMatchers", "pm", "m", "shouldBeRemoved", "updatedPolicyMatchers", "updateStore", "Store", "policies", "matchers", "setupPolicyMap", "policyList", "Policy", "p", "processExemptions", "exempt", "e", "removeExemptions", "filteredList", "import_pepr", "injectionLabel", "injectionAnnotation", "enableInjection", "pkg", "sourceNS", "labels", "annotations", "pkgKey", "killPods", "__name", "cleanupNamespace", "key", "ns", "pods", "groups", "pod", "foundSidecar", "c", "controlledBy", "ref", "group", "a", "b", "import_pepr", "import_pepr", "domain", "UDSConfig", "sanitizeResourceName", "name", "__name", "getOwnerRef", "cr", "uid", "apiURL", "secretTemplateRegex", "keycloak", "pkg", "clientReqs", "refs", "clientReq", "ref", "syncClient", "purgeSSOClients", "__name", "toRemove", "client", "token", "Store", "clientId", "apiCall", "isAuthSvcClient", "secretName", "secretTemplate", "isRetry", "name", "getOwnerRef", "generateSecretData", "err", "msg", "sso", "method", "authToken", "UDSConfig", "req", "url", "resp", "templateData", "stringMap", "key", "value", "processed", "templated", "_match", "fieldName", "json", "import_pepr", "META_IP", "cloudMetadata", "anywhere", "META_IP", "apiServerPeers", "initAPIServerCIDR", "slice", "svc", "updateAPIServerCIDR", "__name", "kubeAPI", "anywhere", "updateAPIServerCIDRFromEndpointSlice", "updateAPIServerCIDRFromService", "endpoints", "k8sApiIP", "peers", "e", "ip", "netPols", "netPol", "oldPeers", "checkForSlashes", "name", "__name", "validNs", "kindToPolicyMap", "Policy", "p", "exemptValidator", "req", "exempt", "exemptions", "UDSConfig", "e", "policies", "validKind", "err", "import_pepr", "virtualService", "pkg", "namespace", "pkgName", "generation", "exposeList", "payloads", "expose", "gateway", "host", "port", "service", "advancedHTTP", "name", "generateVSName", "domain", "UDSConfig", "fqdn", "http", "route", "payload", "getOwnerRef", "virtualservice_v1beta1_exports", "orphanedVS", "vs", "v", "__name", "description", "matchHash", "m", "nameSuffix", "sanitizeResourceName", "intraNamespace", "generate", "namespace", "policy", "generated", "generateName", "peers", "namespaceSelector", "kubeAPI", "cloudMetadata", "intraNamespace", "anywhere", "ports", "port", "__name", "name", "migrate", "pkg", "exposeList", "expose", "allowList", "allow", "__name", "invalidNamespaces", "validator", "req", "pkg", "migrate", "ns", "exposeList", "virtualServiceNames", "expose", "name", "generateVSName", "networkPolicy", "networkPolicyNames", "policy", "sanitizeResourceName", "generateName", "ssoClients", "clientIDs", "client", "__name", "import_pepr", "import_pepr", "uidSeen", "shouldSkip", "cr", "isPending", "isCurrentGeneration", "__name", "updateStatus", "status", "model", "Package", "Exemption", "writeEvent", "event", "handleFailure", "err", "metadata", "identifier", "finalErr", "exemptReconciler", "exempt", "shouldSkip", "metadata", "namespace", "name", "updateStatus", "processExemptions", "e", "err", "handleFailure", "__name", "import_pepr", "import_pepr", "allowEgressDNS", "__name", "namespace", "netPol", "generate", "allowEgressIstiod", "__name", "namespace", "generate", "allowIngressSidecarMonitoring", "__name", "namespace", "generate", "defaultDenyAll", "namespace", "__name", "networkPolicies", "pkg", "namespace", "customPolicies", "pkgName", "generation", "policies", "defaultDenyAll", "allowEgressDNS", "allowEgressIstiod", "allowIngressSidecarMonitoring", "policy", "generatedPolicy", "generate", "exposeList", "expose", "exp", "gateway", "port", "selector", "targetPort", "idx", "sanitizeResourceName", "getOwnerRef", "orphanedNetPol", "netPol", "__name", "packageReconciler", "pkg", "metadata", "namespace", "name", "shouldSkip", "migrate", "updateStatus", "netPol", "networkPolicies", "endpoints", "UDSConfig", "enableInjection", "virtualService", "ssoClients", "keycloak", "err", "handleFailure", "__name", "initAPIServerCIDR", "When", "updateAPIServerCIDRFromEndpointSlice", "updateAPIServerCIDRFromService", "Package", "pkg", "cleanupNamespace", "purgeSSOClients", "validator", "packageReconciler", "Exemption", "removeExemptions", "exemptValidator", "exemptReconciler", "package_default", "operator", "policies", "istio"]
}
